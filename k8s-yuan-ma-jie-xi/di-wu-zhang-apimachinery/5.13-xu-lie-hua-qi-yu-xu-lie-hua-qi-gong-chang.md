# 5.13 åºåˆ—åŒ–å™¨ä¸åºåˆ—åŒ–å™¨å·¥å‚

## èµ„æºçš„å†…éƒ¨ç‰ˆæœ¬

æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨Goè¯­è¨€ä¸­ï¼ŒJSONç¼–ç çš„å­—èŠ‚åºåˆ—ï¼ˆ`[]byte`ï¼‰ä¸Goç±»å‹ï¼ˆ`struct`ï¼‰ä¹‹é—´çš„è½¬æ¢å…¶å®ååˆ†ç®€å•ï¼Œåªè¦åˆ©ç”¨æ ‡å‡†åº“`encoding/json`çš„`json.Unmarshal`ä»¥åŠ`json.Marshal`å°±å¯ä»¥è½»æ¾å®Œæˆã€‚

è€Œåœ¨Kubernetesä¸­ï¼Œå¯¹èµ„æºçš„ç¼–/è§£ç è¿˜åŒ…æ‹¬ä¸€äº›ç‰¹æ®Šçš„æœºåˆ¶ï¼Œè¿™äº›ç‰¹æœ‰çš„æœºåˆ¶ä¹Ÿå¯¼è‡´äº†`apimachinery`åº“ä¸­ç¼–/è§£ç ç›¸å…³ä»£ç çš„å¤æ‚æ€§ã€‚

è€Œè¿™äº›ç‰¹æ®Šæœºåˆ¶çš„æœ¬è´¨æ¥è‡ªäºKubernetesçš„ä¸­ä¸€ä¸ªç‰¹æ®Šæ¦‚å¿µâ€”â€”èµ„æºçš„\_å†…éƒ¨ç‰ˆæœ¬\_ï¼ˆinternal/hub versionï¼‰ã€‚

æˆ‘ä»¬ä¹‹å‰å·²ç»å¤šæ¬¡å¼ºè°ƒäº†èµ„æºç‰ˆæœ¬è¿™ä¸ªé‡è¦æ¦‚å¿µï¼Œä¸è¿‡èµ„æºçš„å¤šç‰ˆæœ¬å¯¹äº`kube-apiserver`æ¥è¯´ï¼Œè¿™å´æ˜¯ä¸€ä¸ªç›¸å½“æ£˜æ‰‹çš„é—®é¢˜ã€‚ `kube-apiserver`ä»å¤„ç†HTTPè¯·æ±‚å¼€å§‹åˆ°æœ€ç»ˆå°†èµ„æºå­˜å…¥`etcd`ä¸­è¿™ä¸­é—´æœ‰ä¸€ç³»åˆ—æ­¥éª¤æµç¨‹éœ€è¦å®Œæˆï¼Œè¿™ä¸åœ¨æœ¬æ–‡çš„è®¨è®ºèŒƒå›´ä¹‹å†…ã€‚æ€»ä¹‹ï¼Œå¯¹äº`kube-apiserver`ç»„ä»¶æ¥è¯´ï¼Œå¦‚æœä¸é’ˆå¯¹èµ„æºçš„å¤šç‰ˆæœ¬æƒ…å†µåŠ ä»¥é¢å¤–å¤„ç†ï¼Œè¿™æ„å‘³ç€å®ƒéœ€è¦ä¸ºèµ„æºçš„æ¯ä¸ªç‰ˆæœ¬é‡å†™ç›¸åŒçš„é€»è¾‘ï¼Œè¿™æ˜¾ç„¶ä¸æ˜¯ä¸€ä¸ªå¥½çš„æ–¹å¼ã€‚

å› æ­¤ï¼Œèµ„æºçš„\_å†…éƒ¨ç‰ˆæœ¬\_çš„æå‡ºæ˜¯ä¸ºäº†è§£å†³`kube-apiserver`åœ¨å¤„ç†èµ„æºå¤šç‰ˆæœ¬æ—¶çš„ç—›ç‚¹ã€‚ å…·ä½“æ¥è¯´ï¼Œ`kube-apiserver`åœ¨ååºåˆ—åŒ–HTTPè¯·æ±‚ä½“ä¸­çš„èµ„æºæ—¶ï¼Œä¼šå†å°†èµ„æºè½¬åŒ–ä¸º\_å†…éƒ¨ç‰ˆæœ¬\_è¿›è€Œå¯ä»¥**ç»Ÿä¸€**å¤„ç†ã€‚

ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯ä»‹ç»äº†`kube-apiserver`åœ¨æ¥å—åˆ°HTTPè¯·æ±‚åï¼Œä¼šå°†èµ„æºåºåˆ—åŒ–åè½¬åŒ–ä¸ºå…¶å†…éƒ¨ç‰ˆæœ¬ã€‚ å…¶å®åœ¨æ­¤ä¹‹åå†…éƒ¨ç‰ˆæœ¬è¿˜éœ€è¦å†è½¬åŒ–æˆå…¶\_å­˜å‚¨ç‰ˆæœ¬\_å­˜å…¥`etcd`ä¸­ã€‚ æ–‡æ¡£[API Changes](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#operational-overview) é‡Œç®€å•æ¦‚æ‹¬äº†èµ„æºåœ¨ä¸€æ¬¡HTTPè¯·æ±‚é‡Œæ‰€è¦ç»å†çš„å„æ¬¡è½¬åŒ–ï¼š

> 1. A user POSTs a Pod object to /api/v7beta1/...
> 2. The JSON is unmarshalled into a v7beta1.Pod structure
> 3. Default values are applied to the v7beta1.Pod
> 4. The v7beta1.Pod is converted to an hub.Pod internal version
> 5. The hub.Pod is validated, and any errors are returned to the user
> 6. The hub.Pod is converted to a v6.Pod (because v6 is the latest stable version)
> 7. The v6.Pod is marshalled into JSON and written to etcd

é™¤æ­¤ä»¥å¤–ï¼Œåœ¨HTTPè¯·æ±‚è¿”å›æ—¶ï¼Œè¿˜éœ€è¦å†å°†å†…éƒ¨ç‰ˆæœ¬è½¬åŒ–ä¸ºå‘é€æ—¶çš„ç‰ˆæœ¬è¿”å›ç»™å®¢æˆ·ç«¯ã€‚è¿™ä¸ªåå‘è½¬åŒ–çš„è¿‡ç¨‹æˆ‘ä»¬ä¸å†èµ˜è¿°ã€‚

## Kubernetesç¼–/è§£ç ä½“ç³»æ¼”åŒ–å†å² <a href="#kubernetes-bian-jie-ma-ti-xi-yan-hua-li-shi" id="kubernetes-bian-jie-ma-ti-xi-yan-hua-li-shi"></a>

åœ¨æˆ‘çœ‹æ¥ï¼ŒKubernetesæ•´ä½“ç¼–/è§£ç ä½“ç³»çš„æ¼”åŒ–å’Œå½¢æˆå…±åˆ†ä¸ºå››ä¸ªé˜¶æ®µï¼š"å¤ä»£"ï¼Œ"è¿‘ä»£" [Pull Request #196](https://github.com/kubernetes/kubernetes/pull/196)ï¼Œ"ç°ä»£" [Pull Request #723](https://github.com/kubernetes/kubernetes/pull/723)ï¼Œ"å½“ä»£" [Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922) Codecæ—¶æœŸä¹Ÿæ­£æ˜¯ **ç°åœ¨** Kubernetesæ‰€ä½¿ç”¨çš„ç¼–/è§£ç ä½“ç³»ã€‚

### å¤ä»£é˜¶æ®µ

æ‰€è°“"å¤ä»£"æ˜¯æŒ‡è‡ªKubernetesæºç å…¬å¸ƒå¼€å§‹ï¼Œç¼–/è§£ç ç”šè‡³è¿˜æœªå½¢æˆä½“ç³»çš„æ—¶æœŸï¼Œ`kube-apiserver`åœ¨HTTPè¯·æ±‚çš„handlerä¸­ç›´æ¥ä½¿ç”¨`json.Marshal`å®Œæˆåºåˆ—åŒ–ã€‚

### è¿‘ä»£é˜¶æ®µ

"è¿‘ä»£"æ˜¯æŒ‡Kubernetesç¼–/è§£ç ä½“ç³»å¼€å§‹é€æ¸å½¢æˆçš„æ—¶æœŸã€‚è¿™ä¸ªæ—¶æœŸç¤¾åŒºå¼€å‘è€…ä¸ºKubernetesçš„ç¼–/è§£ç å¼•å…¥äº†ä¸€äº›å…³é”®æ€§çš„æœºåˆ¶ï¼Œè¿™äº›æœºåˆ¶ä¹Ÿä¸€ç›´è¢«æ²¿ç”¨è‡³ä»Šã€‚è¿™äº›æœºåˆ¶åŒ…æ‹¬ï¼š

1.  [Pull Request #196](https://github.com/kubernetes/kubernetes/pull/196)

    ä¼´éšç€`kind`å­—æ®µå¼•å…¥APIç±»å‹çš„åŒæ—¶ï¼Œ`Encode()/Decode()`å‡½æ•°ç”¨äºæ›¿ä»£`json.Marshal()/json.Unmarshal`ä¹Ÿæ­£å¼è¿›å…¥Kubernetesæºç ä¸­ï¼Œ ç¼–/è§£ç ä½“ç³»å¼€å§‹å¤„äºèŒèŠ½é˜¶æ®µã€‚ å…·ä½“æ¥è¯´ï¼ŒPRä½œè€…å¼•å…¥äº†ä¸¤ä¸ªä¸ç¼–/è§£ç æœ‰å…³çš„æœºåˆ¶ï¼š

    * "æ™ºèƒ½æ¨æ–­"æœºåˆ¶â€”â€”åœ¨è§£ç çš„åˆå§‹é˜¶æ®µæ ¹æ®JSONå­—èŠ‚åºåˆ—çš„`kind`å­—æ®µæå‰è·å–APIç±»å‹ä¿¡æ¯



    ```go
    findKind := struct {
        Kind string `json:"kind,omitempty" yaml:"kind,omitempty"`
    }{}
    err := yaml.Unmarshal(data, &findKind)
    ```

    åŸç†å…¶å®éå¸¸ç®€å•ï¼Œå…ˆåˆ›å»ºåªæœ‰ä¸€ä¸ª`Kind`å­—æ®µçš„ç©ºç»“æ„ä½“`findKind`ï¼Œå†å°è¯•å°†åŸå§‹å­—èŠ‚åºåˆ—`data`è§£ç ä¸º`findKind`ç»“æ„ï¼Œè¿™æ ·å°±å¯ä»¥ç‡å…ˆ"æ•è·"åŸå§‹å­—èŠ‚ä¸­åŒ…å«çš„`kind`ä¿¡æ¯ã€‚

* "APIç±»å‹æ³¨å†Œ"æœºåˆ¶â€”â€”å°†æ‰€æœ‰çš„APIç±»å‹[1](https://caozhuozi.github.io/crd-controller-from-scratch/docs/apimachinery/serializer#fn-1)äº‹å…ˆæ³¨å†Œï¼Œåœ¨"æ™ºèƒ½æ¨æ–­"æœºåˆ¶è·å–APIç±»å‹ä¿¡æ¯åæŸ¥è¡¨ç›´æ¥è·å–APIç±»å‹ã€‚

1.  [Pull Request #565](https://github.com/kubernetes/kubernetes/pull/565)

    ä¼´éšç€`apiVersion`å­—æ®µå¼•å…¥APIç±»å‹ï¼ŒAPIå¯¹è±¡çš„\_å†…éƒ¨ç‰ˆæœ¬\_çš„æ¦‚å¿µå¼€å§‹å‡ºç°ã€‚ç›¸åº”åœ°ï¼Œ"ç‰ˆæœ¬è½¬åŒ–"æœºåˆ¶ä¹Ÿå¼€å§‹æ­£å¼è¿›å…¥ç¼–/è§£ç æµç¨‹ã€‚
2.  [Pull Request #672](https://github.com/kubernetes/kubernetes/pull/672)

    åœ¨è¿™ä¸ªPRä¸­ï¼Œä½œè€…å¼•å…¥"ç‰ˆæœ¬è½¬åŒ–å‡½æ•°æ³¨å†Œ"æœºåˆ¶ï¼Œç”¨äºä¼˜åŒ–ç‰ˆæœ¬è½¬åŒ–æµç¨‹ï¼›

åœ¨"è¿‘ä»£"é˜¶æ®µï¼Œæ‰€æœ‰ç¼–/è§£ç ä»£ç è¢«æ”¾ç½®åœ¨`pkg/api/helper.go`ä¸­â€”â€”è¿™è¯´æ˜ç¼–/è§£ç åœ¨å½“æ—¶å¹¶æœªå¼•èµ·ç¤¾åŒºè¶³å¤Ÿçš„é‡è§†ã€‚

### ç°ä»£é˜¶æ®µï¼ˆSchemeå¤§ä¸€ç»Ÿæ—¶æœŸï¼‰

"ç°ä»£" é˜¶æ®µæ˜¯æŒ‡ä» [Pull Request #723](https://github.com/kubernetes/kubernetes/pull/723)å¼€å§‹çš„æ—¶æœŸã€‚ åœ¨è¯¥PRä¸­ï¼Œä½œè€…å…¶å®æ²¡æœ‰å¼•å…¥æ–°çš„æœºåˆ¶æˆ–æ˜¯æ”¹åŠ¨åŸæ¥çš„ç¼–/è§£ç é€»è¾‘ï¼Œä½œè€…åªæ˜¯æŠŠåŸæ¥`pkg/api/helper.go`ä¸­åˆ†æ•£çš„ç¼–/è§£ç é€»è¾‘å’Œæœºåˆ¶æ•´ä½“è¿ç§»å¹¶å°è£…åˆ°äº†ä¸€ä¸ªå«åš`Scheme`çš„ç±»å‹ä¸­ã€‚åŒæ—¶åˆ é™¤äº†åŸå…ˆçš„`pkg/api/helper.go`æ–‡ä»¶ã€‚ æˆ‘ä»¬æŠŠ [Pull Request #723](https://github.com/kubernetes/kubernetes/pull/723)å•ç‹¬æå‡åˆ°ä¸€ä¸ªé˜¶æ®µçš„åŸå› æ˜¯ï¼šç»è¿‡æ•´ç†åçš„ç¼–/è§£ç ä»£ç é€»è¾‘å¼‚å¸¸æ¸…æ™°ï¼Œä¸€ä¸ª`Scheme`ç±»å‹å›Šæ‹¬äº†"è¿‘ä»£"é˜¶æ®µæ‰€æ–­æ–­ç»­ç»­å¼•å…¥çš„å„ä¸ªæœºåˆ¶ã€‚

```go
// Scheme defines an entire encoding and decoding scheme.
type Scheme struct {
    // versionMap allows one to figure out the go type of an object with
    // the given version and name.
    versionMap map[string]map[string]reflect.Type

    // converter stores all registered conversion functions. It also has
    // default coverting behavior.
    converter *Converter

    // MetaInsertionFactory is used to create an object to store and retrieve
    // the version and kind information for all objects. The default uses the
    // keys "version" and "kind" respectively.
    MetaInsertionFactory MetaInsertionFactory
}
```

å…¶ä¸­ï¼š

* `MetaInsertionFactory`æˆå‘˜ç”¨äº"æ™ºèƒ½æ¨æ–­"æœºåˆ¶ï¼›
* `versionMap`æˆå‘˜ç”¨äº"APIç±»å‹æ³¨å†Œ"æœºåˆ¶ï¼›
* `converter`æˆå‘˜ç”¨äº"ç‰ˆæœ¬è½¬åŒ–"ã€‚

ä»¥ç»è¿‡æ•´ç†åçš„è§£ç å‡½æ•°ä¸ºä¾‹ï¼š

pkg/api/conversion/decode.go

```go
nversion/decode.go
// Decode converts a YAML or JSON string back into a pointer to an api object.
// Deduces the type based upon the fields added by the MetaInsertionFactory
// technique. The object will be converted, if necessary, into the
// s.InternalVersion type before being returned. Decode will refuse to decode
// objects without a version, because that's probably an error.
func (s *Scheme) Decode(data []byte) (interface{}, error) {
    version, kind, err := s.DataVersionAndKind(data)
    if err != nil {
        return nil, err
    }
    if version == "" {
        return nil, fmt.Errorf("version not set in '%s'", string(data))
    }
    obj, err := s.NewObject(version, kind)
    if err != nil {
        return nil, err
    }
    // yaml is a superset of json, so we use it to decode here. That way,
    // we understand both.
    err = yaml.Unmarshal(data, obj)
    if err != nil {
        return nil, err
    }

    // Version and Kind should be blank in memory.
    err = s.SetVersionAndKind("", "", obj)
    if err != nil {
        return nil, err
    }

    // Convert if needed.
    if s.InternalVersion != version {
        objOut, err := s.NewObject(s.InternalVersion, kind)
        if err != nil {
            return nil, err
        }
        err = s.converter.Convert(obj, objOut, 0)
        if err != nil {
            return nil, err
        }
        obj = objOut
    }
    return obj, nil
}
```

è§£ç è¿‡ç¨‹å¯ä»¥æ¸…æ™°åœ°åˆ’åˆ†ä¸º5ä¸ªæ­¥éª¤ï¼š

1.  æ™ºèƒ½æ¨æ–­

    è°ƒç”¨`DataVersionAndKind()`å‡½æ•°æ¨æ–­å­—èŠ‚åºåˆ—çš„`kind`å’Œ`apiVersion`ï¼ˆå½¼æ—¶ï¼ŒAPIåˆ†ç»„çš„æ¦‚å¿µè¿˜æ²¡æœ‰å‡ºç°ï¼‰ã€‚
2.  åˆ›å»ºAPIå¯¹è±¡è½½ä½“

    è·å–APIå¯¹è±¡çš„ç±»å‹å’Œç‰ˆæœ¬ä¿¡æ¯åï¼Œè°ƒç”¨`NewObject()`åˆ›å»ºä¸€ä¸ªå¯¹åº”ç±»å‹å’Œç‰ˆæœ¬çš„APIå¯¹è±¡çš„"ç©ºè½½ä½“"ã€‚
3.  ååºåˆ—åŒ–

    è°ƒç”¨`Unmarshal()`å°†å­—èŠ‚åºåˆ—åºåˆ—åŒ–åˆ°ä¸Šä¸€æ­¥åˆ›å»ºçš„APIå¯¹è±¡è½½ä½“ä¸­ï¼›
4. ç‰ˆæœ¬è½¬åŒ–
   * è°ƒç”¨`SetVersionAndKind()`å‡½æ•°å°†APIå¯¹è±¡çš„`apiVersion`å’Œ`kind`å­—æ®µè‡³ç©º;
   * è°ƒç”¨`NewObject()`åˆ›å»ºAPIå¯¹è±¡çš„å†…éƒ¨ç‰ˆæœ¬çš„"ç©ºè½½ä½“";
   * è°ƒç”¨`Convert()`å°†APIå¯¹è±¡è½¬åŒ–ä¸ºå…¶å†…éƒ¨ç‰ˆæœ¬ã€‚
5. è¿”å›å†…éƒ¨ç‰ˆæœ¬

å…¶ä¸­æœ‰ä¸€äº›ç»†èŠ‚éœ€è¦å•ç‹¬è¯´æ˜ï¼š

*   `Scheme`çš„`NewObject()`æ–¹æ³•ç”¨äºåˆ›å»ºç»™å®šç±»å‹å’Œç‰ˆæœ¬çš„APIå¯¹è±¡çš„ç©º"è½½ä½“"ã€‚

    ```go
    // NewObject returns a new object of the given version and name,
    // or an error if it hasn't been registered.
    func (s *Scheme) NewObject(versionName, typeName string) (interface{}, error) {
        if types, ok := s.versionMap[versionName]; ok {
            if t, ok := types[typeName]; ok {
                return reflect.New(t).Interface(), nil
            }
            return nil, fmt.Errorf("No type '%v' for version '%v'", typeName, versionName)
        }
        return nil, fmt.Errorf("No version '%v'", versionName)
    }
    ```

    å…·ä½“å®ç°ä¸Šå®ƒéœ€è¦æŸ¥è¯¢`versionMap`è¿™å¼ è¡¨ï¼Œåªæœ‰åœ¨è¿™å¼ è¡¨ä¸­æ³¨å†Œè¿‡çš„APIç±»å‹æ‰èƒ½è¢«åˆ›å»ºã€‚
*   `Scheme`çš„`DataVersionAndKind()`æ–¹æ³•ç”¨äº"æ™ºèƒ½æ¨æ–­"ã€‚

    ```go
    // DataAPIVersionAndKind will return the APIVersion and Kind of the given wire-format
    // enconding of an API Object, or an error.
    func (s *Scheme) DataVersionAndKind(data []byte) (version, kind string, err error) {
        findKind := s.MetaInsertionFactory.Create("", "")
        // yaml is a superset of json, so we use it to decode here. That way,
        // we understand both.
        err = yaml.Unmarshal(data, findKind)
        if err != nil {
            return "", "", fmt.Errorf("couldn't get version/kind: %v", err)
        }
        version, kind = s.MetaInsertionFactory.Interpret(findKind)
        return version, kind, nil
    }

    ```



åœ¨å®ç°ä¸Šå®ƒä¾èµ–äº`MetaInsertionFactory`æˆå‘˜ã€‚å…·ä½“çš„æ™ºèƒ½æ¨ç†è¿‡ç¨‹åŸç†åŸºæœ¬ä¸"è¿‘ä»£"é˜¶æ®µä¸€è‡´ï¼Œæˆ‘ä»¬ä¸å†èµ˜è¿°ã€‚

ä¸‹å›¾æ€»ç»“äº†æ­¤æ—¶æœŸçš„è§£ç è¿‡ç¨‹ï¼ˆä¸åŒ…æ‹¬ç‰ˆæœ¬è½¬åŒ–ï¼‰ï¼š

<figure><img src="../../.gitbook/assets/1726730231838.png" alt=""><figcaption></figcaption></figure>

### å½“ä»£é˜¶æ®µ

Kuberneteså¦‚ä»Šä½¿ç”¨çš„ç¼–/è§£ç ä½“ç³»æ¥è‡ªäºä¸€æ¬¡é‡å¤§é‡æ„:ç›¸å…³ææ¡ˆ [Issues #7111](https://github.com/kubernetes/kubernetes/issues/7111)åŠå®ç° [Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922)ã€‚

> å½“æ—¶Kubernetesç‰ˆæœ¬å·²ç»æ¥è¾¾äº†[v1.2.0-alpha.7](https://github.com/kubernetes/kubernetes/tree/v1.2.0-alpha.7)ï¼ŒKubernetes APIç±»å‹ç³»ç»Ÿï¼ˆ_èµ„æº_ï¼Œ_APIåˆ†ç»„_ï¼Œ_kind_ï¼Œ`runtime.Object`æ¥å£ï¼Œ\_GVK\_ç­‰ï¼‰å·²ç»åŸºæœ¬è¶‹å‘æˆç†Ÿã€‚ è€Œæ­¤å‰æˆ‘ä»¬æ‰€ä»‹ç»çš„ä¸‰ä¸ªé˜¶æ®µç”šè‡³éƒ½åœ¨Kubernetesä»“åº“æ‰“çš„ç¬¬ä¸€ä¸ªtag[v0.2](https://github.com/kubernetes/kubernetes/tree/v0.2)ä¹‹å‰ã€‚

ç”±äº [Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922)å¥ å®šäº†å¦‚ä»Šçš„Kubernetesç¼–/è§£ç ä½“ç³»ï¼Œå¹¶ä¸”åœ¨å†…å®¹ä¸Šè¿›è¡Œäº†å¤§é‡çš„é‡æ„ã€‚æˆ‘ä»¬å°†æŠŠå®ƒæ”¾åœ¨å•ç‹¬çš„å°èŠ‚ä»‹ç»ã€‚

## Codecä½“ç³»

åœ¨ææ¡ˆ [Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111)ä¸­ï¼Œä½œè€…å†³å®šå°†`Scheme`è§£è€¦, åŒæ—¶ä½œè€…ä¹Ÿç»™å‡ºäº†é‡æ„çš„å¤§è‡´æ–¹å‘ä¸è¦è§£å†³çš„é—®é¢˜ï¼š

æ€»ç»“æ¥è¯´ï¼Œä½œè€…å†³å®šå°†ç¼–/è§£ç é€»è¾‘æ•´ä½“ä»`Scheme`ä¸­å‰¥ç¦»ï¼Œå¹¶ä¿ç•™`Scheme`ç±»å‹çš„"APIç±»å‹æ³¨å†Œ"æœºåˆ¶ï¼ŒåŒæ—¶å¯ç”¨`Codec`æ¦‚å¿µä¸“é—¨ç”¨äºè´Ÿè´£ç¼–/è§£ç ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æŠŠKubernetes"å½“ä»£"ç¼–/è§£ç ä½“ç³»ç§°ä¸º"Codecä½“ç³»"ã€‚

### æ¥å£

åœ¨ä¸Šè¿°ææ¡ˆçš„å®ç° [Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922) ä¸­ï¼Œä½œè€…é¦–å…ˆæŠ½è±¡äº†ä¸€ç³»åˆ—æ¥å£ï¼š`Encoder`ï¼Œ`Decoder`ï¼Œ`Codec`ï¼Œ `NegotiatedSerializer`ï¼š

```go
// Encoder writes objects to a serialized form
type Encoder interface {
	// Encode writes an object to a stream. Implementations may return errors if the versions are
	// incompatible, or if no conversion is defined.
	Encode(obj Object, w io.Writer) error
	// Identifier returns an identifier of the encoder.
	// Identifiers of two different encoders should be equal if and only if for every input
	// object it will be encoded to the same representation by both of them.
	//
	// Identifier is intended for use with CacheableObject#CacheEncode method. In order to
	// correctly handle CacheableObject, Encode() method should look similar to below, where
	// doEncode() is the encoding logic of implemented encoder:
	//   func (e *MyEncoder) Encode(obj Object, w io.Writer) error {
	//     if co, ok := obj.(CacheableObject); ok {
	//       return co.CacheEncode(e.Identifier(), e.doEncode, w)
	//     }
	//     return e.doEncode(obj, w)
	//   }
	Identifier() Identifier
}

type Decoder interface {
    // Decode attempts to deserialize the provided data using either the innate typing of the scheme or the
    // default kind, group, and version provided. It returns a decoded object as well as the kind, group, and
    // version from the serialized data, or an error. If into is non-nil, it will be used as the target type
    // and implementations may choose to use it rather than reallocating an object. However, the object is not
    // guaranteed to be populated. The returned object is not guaranteed to match into. If defaults are
    // provided, they are applied to the data by default. If no defaults or partial defaults are provided, the
    // type of the into may be used to guide conversion decisions.
    Decode(data []byte, defaults *unversioned.GroupVersionKind, into Object) (Object, *unversioned.GroupVersionKind, error)
}
```



`Decoder`æ¥å£æ‰€æè¿°çš„è§£ç å‡½æ•°ç­¾åä¸"è¿‘ä»£"å’Œ"ç°ä»£"é˜¶æ®µçš„è§£ç å‡½æ•°ç­¾åäº§ç”Ÿäº†è¾ƒå¤§çš„åŒºåˆ«ã€‚ "è¿‘ä»£"å’Œ"ç°ä»£"é˜¶æ®µæ‰€ç”¨çš„è§£ç å‡½æ•°ç­¾åå…¶å®é€šä¿—å¸¸è§ï¼š`func Decode(data []byte) (interface{}, error)`ã€‚ é™¤äº†åŸå§‹å­—èŠ‚åºåˆ—æ•°æ®`data`è¿™ä¸ªå‚æ•°ä»¥å¤–ï¼Œè¿˜éœ€è¦æä¾›`defaults`ä»¥åŠ`into`ä¸¤ä¸ªå‚æ•°ã€‚è¿™æ ·è®¾è®¡è§£ç æ–¹æ³•çš„åŠ¨æœºæ˜¯å¸¦æ¥äº†æ›´å¤šçš„çµæ´»æ€§ã€‚ PRä½œè€…å¸Œæœ›è§£ç å™¨ï¼š

1. å¦‚æœè°ƒç”¨è€…å·²ç»é¢„å…ˆæä¾›äº†è§£ç åçš„\_kind\_"ç©ºè½½ä½“"ï¼ˆ`into`ï¼‰ï¼Œè§£ç å™¨åº”è¯¥å°½é‡ä½¿ç”¨è°ƒç”¨è€…æä¾›çš„è½½ä½“è€Œé¿å…åœ¨å†…å­˜ä¸­å†åˆ†é…ä¸€ä¸ªæ–°å¯¹è±¡ï¼›
2. é€šè¿‡åŸå§‹å­—èŠ‚åºåˆ—ï¼ˆ`data`ï¼‰åŒ…å«çš„GVKä¿¡æ¯ã€è°ƒç”¨è€…é»˜è®¤æä¾›çš„GVKä¿¡æ¯ï¼ˆ`defaults`ï¼‰ã€è°ƒç”¨è€…æä¾›çš„"ç©ºè½½ä½“"ï¼ˆ`into`ï¼‰ä¸­åŒ…å«çš„GVKä¿¡æ¯å…±åŒæ¨æ–­å‡ºä¸€ä¸ªå¯èƒ½çš„GVKã€‚

> è¿™æ ·è®¾è®¡çš„ä¸€ä¸ªå¥½å¤„æ˜¯å¯¹äºåŸå§‹å­—èŠ‚æ•°æ®ä¸¢å¤±æˆ– GVK ä¿¡æ¯æ®‹ç¼ºçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨è€…æä¾›çš„GVKä¿¡æ¯ï¼ˆ`defaults`ï¼‰ç”šè‡³æ˜¯`into`çš„GVKä¿¡æ¯å…œåº•ã€‚ å½“ç„¶ï¼Œè¿™ç§çµæ´»æ€§ä¹Ÿå¸¦æ¥äº†å®ç°ä¸Šçš„ä¸æ–¹ä¾¿ã€‚å°¤å…¶æ˜¯åŸå§‹æ•°æ®åŒ…å«çš„å®é™…GVKä¿¡æ¯å’Œè°ƒç”¨è€…æä¾›çš„GVKä¿¡æ¯ä»¥åŠ`into`çš„GVKä¸ä¸€è‡´çš„æƒ…å†µã€‚ å› æ­¤åœ¨è§£ç å™¨æ¥å£çš„å®ç°ä¸­ï¼ˆä¾‹å¦‚æˆ‘ä»¬åç»­ä»‹ç»çš„ JSON åºåˆ—åŒ–å™¨ï¼‰ï¼Œæœ‰ç›¸å½“ä¸€éƒ¨åˆ†é€»è¾‘åœ¨å¤„ç†è¿™ç§æƒ…å½¢ã€‚

*   `Codec`â€”â€”\_ç¼–è§£ç¼–ç å™¨\_æ¥å£ï¼š

    ```go
    // Codec defines methods for serializing and deserializing API objects.
    // Codecæ¥å£æŠ½è±¡äº†å®ç°ç±»éœ€è¦åŒæ—¶å…·å¤‡ç¼–ç ä»¥åŠè§£ç èƒ½åŠ›ã€‚
    type Codec interface {
        Decoder
        Encoder
    }
    ```


*   `NegotiatedSerializer`â€”â€”\_åå•†åºåˆ—åŒ–å™¨\_æ¥å£ï¼š

    ```go
    // NegotiatedSerializer is an interface used for obtaining encoders, decoders, and serializers
    // for multiple supported media types. This would commonly be accepted by a server component
    // that performs HTTP content negotiation to accept multiple formats.
    type NegotiatedSerializer interface {
    	// SupportedMediaTypes is the media types supported for reading and writing single objects.
    	SupportedMediaTypes() []SerializerInfo

    	// EncoderForVersion returns an encoder that ensures objects being written to the provided
    	// serializer are in the provided group version.
    	EncoderForVersion(serializer Encoder, gv GroupVersioner) Encoder
    	// DecoderToVersion returns a decoder that ensures objects being read by the provided
    	// serializer are in the provided group version by default.
    	DecoderToVersion(serializer Decoder, gv GroupVersioner) Decoder
    }
    ```



PRä½œè€…ç”¨\_Negotiated(åå•†)\_å‘½åæ­¤æ¥å£çš„åŠ¨æœºæ­£å¼æ¥è‡ªäº[_HTTPå†…å®¹åå•†ï¼ˆHTTP Content negotiationï¼‰_](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content\_negotiation)ã€‚ ç®€å•æ¥è¯´ï¼Œ\_HTTPå†…å®¹åå•†\_æ˜¯æŒ‡æœåŠ¡ç«¯ä¸å®¢æˆ·ç«¯"åå•†"è¿”å›èµ„æºçš„å…·ä½“è¡¨ç¤ºå½¢å¼çš„ä¸€ç§æœºåˆ¶ã€‚ ä¾‹å¦‚ï¼Œæ ¹æ®æ–‡æ¡£ [Kubernetes API Concepts](https://kubernetes.io/docs/reference/using-api/api-concepts) ï¼Œ`kube-apiserver`é™¤äº†æ”¯æŒè¿”å›èµ„æºçš„JSONç¼–ç æ ¼å¼å¤–ï¼Œä¹Ÿæ”¯æŒè¿”å›èµ„æºçš„protobufç¼–ç æ ¼å¼ï¼š

> [Alternate representations of resources](https://kubernetes.io/docs/reference/using-api/api-concepts/#alternate-representations-of-resources)
>
> List all of the pods on a cluster in Protobuf format.
>
> ```
> GET /api/v1/pods
> Accept: application/vnd.kubernetes.protobuf
> ---
> 200 OK
> Content-Type: application/vnd.kubernetes.protobuf
>
> ... binary encoded PodList object
> ```

å› æ­¤ï¼Œ\_åå•†åºåˆ—åŒ–å™¨\_æ¥å£æ‰€è¦æŠ½è±¡çš„èƒ½åŠ›æ˜¯æ”¯æŒåŒæ—¶å¯¹å¤šç§æ•°æ®æ ¼å¼çš„ç¼–/è§£ç ã€‚æ­£å¦‚ä½œè€…åœ¨ææ¡ˆ [Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111) ä¸­æè¿°çš„é‚£æ ·ï¼š

> It's likely that there exists one canonical "marshaller" for most objects, but there may be alternate mechanisms. For example, JSON is canonical for Kube, but we may occasionally want to marshal an annotated YAML object that has description comments for each field interleaved.

å…·ä½“æ¥è¯´ï¼š

* `SupportedMediaTypes()`æè¿°äº†å®ç°ç±»éœ€è¦è¿”å›æ­¤åºåˆ—åŒ–å™¨æ”¯æŒçš„æ‰€æœ‰ç¼–ç æ ¼å¼ï¼›

\_åå•†åºåˆ—åŒ–å™¨\_é™¤äº†å¯ä»¥"åå•†"ç¼–ç æ ¼å¼ä»¥å¤–ï¼Œ**å®ƒçš„å¦ä¸€ä¸ªç‰¹ç‚¹æ˜¯æ”¯æŒ"åå•†"ç‰ˆæœ¬è½¬åŒ–æ—¶çš„ç›®æ ‡ç‰ˆæœ¬**ã€‚ æˆ‘ä»¬ç°åœ¨å·²ç»çŸ¥é“ç¼–/è§£ç ä½“ç³»çš„"ç°ä»£"é˜¶æ®µï¼Œç¼–/è§£ç æ—¶é»˜è®¤è½¬åŒ–ä¸ºå…¶å†…éƒ¨ç‰ˆæœ¬ã€‚è€Œåœ¨è¿™æ¬¡é‡æ„ä¸­ï¼Œä½œè€…å†³å®šæ”¯æŒä»»æ„ä¸åŒç‰ˆæœ¬ä¹‹é—´çš„è½¬åŒ–ï¼Œæ­£å¦‚ä½œè€…åœ¨ææ¡ˆ [Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111)ä¸­æè¿°çš„é‚£æ ·ï¼š

> It should be possible to convert a versioned Go struct into a different versioned Go struct (typically by going to an intermediate format) on the server. This is "object versioning".

å…·ä½“æ¥è¯´:

* `EncoderForVersion()/DecoderToVersion()`è¡¨ç¤ºå®ç°ç±»å¯ä»¥æ ¹æ®æŒ‡å®šçš„ç›®æ ‡ç‰ˆæœ¬è¿”å›ä¸€ä¸ªä¸“é—¨è½¬åŒ–ä¸ºè¯¥ç›®æ ‡ç‰ˆæœ¬çš„ç¼–è§£ç å™¨ï¼›

å¦å¤–ï¼Œç›¸æ¯”äºä¹‹å‰çš„å‡ ä¸ªæ¥å£åå‘åº•å±‚ï¼Œ\_åå•†åºåˆ—åŒ–å™¨\_æ¥å£å·²ç»æ˜¯**åº”ç”¨å±‚**çº§åˆ«çš„å°è£…ã€‚ `client-go`ä½œä¸ºå®¢æˆ·ç«¯åº“ï¼Œå®ƒæ‰€ä½¿ç”¨çš„ç¼–è§£ç å™¨æ­£æ˜¯åå•†åºåˆ—åŒ–å™¨ã€‚[ğŸˆ](https://caozhuozi.github.io/crd-controller-from-scratch/docs/intro#%E7%BA%A6%E5%AE%9A)

### å®ç°

ä»‹ç»å®Œæ¥å£ä¹‹åï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥çœ‹ä½œè€…æ˜¯å¦‚ä½•å®ç°è¿™äº›æ¥å£çš„ã€‚

**JSONåºåˆ—åŒ–å™¨**

ä½œè€…åœ¨ [Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922) ä¸­åŒæ—¶æä¾›äº†JSONå’ŒYAMLä¸¤ç§åºåˆ—åŒ–å™¨çš„å®ç°ã€‚

æˆ‘ä»¬ä»¥JSONç¼–è§£ç å™¨ä¸ºä¾‹ï¼Œå®ƒå®ç°çš„æ¥å£æ˜¯ `Codec`ã€‚

```go

// Serializer handles encoding versioned objects into the proper JSON form
type Serializer struct {
	meta    MetaFactory
	options SerializerOptions
	creater runtime.ObjectCreater
	typer   runtime.ObjectTyper

	identifier runtime.Identifier
}
```

å…¶ä¸­ï¼Œ

* `meta`æˆå‘˜ç”¨äº"æ™ºèƒ½æ¨æ–­"ï¼Œå®ƒæ¼”åŒ–äº"ç°ä»£"æ—¶æœŸçš„`MetaInsertionFactory`ã€‚
* `creater`æˆå‘˜ç”¨äºæ ¹æ®ç»™å®šçš„GVKä¸‰å…ƒç»„åˆ›å»ºå¯¹åº”\_kind\_ï¼ˆç©ºï¼‰å®ä¾‹ã€‚
* `typer`æˆå‘˜ç”¨äºåˆ¤å®šä¸€ä¸ªç»™å®šçš„APIå¯¹è±¡æ˜¯å¦æ³¨å†Œè¿‡ã€‚

> å°½ç®¡åœ¨ææ¡ˆ [Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111) ä¸­ï¼Œä½œè€…è™½ç„¶å†³å®šæŠŠç¼–/è§£ç é€»è¾‘ä»`Scheme`ç±»å‹ä¸­å‰¥ç¦»ï¼Œä½†æ˜¯ä½œè€…ä»ç„¶æœ‰æ„ä¿ç•™äº†`Scheme`"APIå¯¹è±¡æ³¨å†Œ"æœºåˆ¶ã€‚æ­£å¦‚ä½œè€…æåˆ°çš„é‚£æ ·ï¼š"Object versioning" requires the registration of an object Kind into an APIVersion for a specific API group. This was the original intent of runtime.Scheme.ä» [Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922) ä¹‹åï¼Œ`Scheme`ç±»å‹ä»…ä»…è¢«ç”¨äºï¼š

* æ³¨å†Œæ‰€æœ‰çš„\_kind\_ï¼ˆAPIå¯¹è±¡ï¼‰ï¼›
* åˆ¤å®šç»™å®šçš„\_kind\_ï¼ˆAPIå¯¹è±¡ï¼‰æ˜¯å¦æ³¨å†Œï¼›
* æ ¹æ®ç»™å®šçš„GVKä¸‰å…ƒç»„åˆ›å»ºå¯¹åº”\_kind\_ï¼ˆAPIå¯¹è±¡ï¼‰çš„ç©ºå®ä¾‹ï¼ˆ"è½½ä½“"ï¼‰ã€‚

> æ‰€ä»¥åœ¨Kubernetesæºç ä¸­ï¼ŒJSONåºåˆ—åŒ–å™¨åœ¨åˆå§‹åŒ–`creater`ï¼Œ`typer`æˆå‘˜æ—¶ä½¿ç”¨çš„æ˜¯`Scheme`å¯¹è±¡ã€‚**æ‰€ä»¥JSONåºåˆ—åŒ–å™¨ä»ç„¶ä¾èµ–`Scheme`çš„æ³¨å†Œæœºåˆ¶å·¥ä½œ**ã€‚

```go
// Decode attempts to convert the provided data into YAML or JSON, extract the stored schema kind, apply the provided default gvk, and then
// load that data into an object matching the desired schema kind or the provided into.
// If into is *runtime.Unknown, the raw data will be extracted and no decoding will be performed.
// If into is not registered with the typer, then the object will be straight decoded using normal JSON/YAML unmarshalling.
// If into is provided and the original data is not fully qualified with kind/version/group, the type of the into will be used to alter the returned gvk.
// If into is nil or data's gvk different from into's gvk, it will generate a new Object with ObjectCreater.New(gvk)
// On success or most errors, the method will return the calculated schema kind.
// The gvk calculate priority will be originalData > default gvk > into
func (s *Serializer) Decode(originalData []byte, gvk *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
	data := originalData
	if s.options.Yaml {
		altered, err := yaml.YAMLToJSON(data)
		if err != nil {
			return nil, nil, err
		}
		data = altered
	}

	actual, err := s.meta.Interpret(data)
	if err != nil {
		return nil, nil, err
	}

	if gvk != nil {
		*actual = gvkWithDefaults(*actual, *gvk)
	}

	if unk, ok := into.(*runtime.Unknown); ok && unk != nil {
		unk.Raw = originalData
		unk.ContentType = runtime.ContentTypeJSON
		unk.GetObjectKind().SetGroupVersionKind(*actual)
		return unk, actual, nil
	}

	if into != nil {
		_, isUnstructured := into.(runtime.Unstructured)
		types, _, err := s.typer.ObjectKinds(into)
		switch {
		case runtime.IsNotRegisteredError(err), isUnstructured:
			strictErrs, err := s.unmarshal(into, data, originalData)
			if err != nil {
				return nil, actual, err
			}

			// when decoding directly into a provided unstructured object,
			// extract the actual gvk decoded from the provided data,
			// and ensure it is non-empty.
			if isUnstructured {
				*actual = into.GetObjectKind().GroupVersionKind()
				if len(actual.Kind) == 0 {
					return nil, actual, runtime.NewMissingKindErr(string(originalData))
				}
				// TODO(109023): require apiVersion here as well once unstructuredJSONScheme#Decode does
			}

			if len(strictErrs) > 0 {
				return into, actual, runtime.NewStrictDecodingError(strictErrs)
			}
			return into, actual, nil
		case err != nil:
			return nil, actual, err
		default:
			*actual = gvkWithDefaults(*actual, types[0])
		}
	}

	if len(actual.Kind) == 0 {
		return nil, actual, runtime.NewMissingKindErr(string(originalData))
	}
	if len(actual.Version) == 0 {
		return nil, actual, runtime.NewMissingVersionErr(string(originalData))
	}

	// use the target if necessary
	obj, err := runtime.UseOrCreateObject(s.typer, s.creater, *actual, into)
	if err != nil {
		return nil, actual, err
	}

	strictErrs, err := s.unmarshal(obj, data, originalData)
	if err != nil {
		return nil, actual, err
	} else if len(strictErrs) > 0 {
		return obj, actual, runtime.NewStrictDecodingError(strictErrs)
	}
	return obj, actual, nil
}

```

JSONåºåˆ—åŒ–å™¨çš„è§£ç è¿‡ç¨‹å¯ä»¥å¤§è‡´åˆ’åˆ†ä¸º5ä¸ªæ­¥éª¤ï¼š

1.  æ™ºèƒ½æ¨æ–­

    è·å–åŸå§‹å­—èŠ‚åºåˆ—ï¼ˆ`originalData`ï¼‰ä¸­çš„GVKä¿¡æ¯ã€‚
2.  **å…±åŒ**æ¨æ–­

    åˆ©ç”¨`originalData`ã€`gvk`ã€`into`ä¸­çš„GVKä¿¡æ¯å…±åŒæ¨æ–­å‡ºä¸€ä¸ªGKVä¸‰å…ƒç»„ã€‚ è¡¥å…¨é¡ºåºä¸ºåŸå§‹å­—èŠ‚æ•°æ®åŒ…å«çš„GVKä¿¡æ¯ä¼˜å…ˆäºè°ƒç”¨è€…ç»™å®šçš„GVKä¿¡æ¯ï¼ˆå‚æ•°`gvk`ï¼‰ä¼˜å…ˆäºè°ƒç”¨è€…æä¾›çš„ç›®æ ‡å¯¹è±¡è½½ä½“ï¼ˆå‚æ•°`into`ï¼‰ã€‚
3.  åˆ›å»º/å¤ç”¨"è½½ä½“"

    è°ƒç”¨`UseOrCreateObject`åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡"è½½ä½“"æˆ–è€…ä½¿ç”¨è°ƒç”¨è€…æä¾›çš„`into`ä½œä¸º"è½½ä½“"ã€‚ å…·ä½“è§„åˆ™ä¸ºï¼šå¦‚æœå…±åŒæ¨æ–­å‡ºçš„GVKä¸‰å…ƒç»„ä¸`into`æ‰€æºå¸¦çš„GVKä¿¡æ¯ä¸åŒ¹é…ï¼Œé‚£ä¹ˆå°†ä¼šåˆ›å»ºå‡ºä¸€ä¸ªä¸æ¨æ–­GVKåŒ¹é…çš„å¯¹è±¡åšä¸ºç›®æ ‡"è½½ä½“"ï¼›
4. ååºåˆ—åŒ–
5. è¿”å›åºåˆ—åŒ–åçš„å¯¹è±¡ä»¥åŠ**å…±åŒæ¨æ–­çš„GVKä¸‰å…ƒç»„**

æˆ‘ä»¬å¯ä»¥çœ‹å‡ºJSONåºåˆ—åŒ–å™¨çš„è§£ç è¿‡ç¨‹ä¸"ç°ä»£"æ—¶æœŸçš„è§£ç è¿‡ç¨‹äº§ç”Ÿäº†ä¸€äº›åŒºåˆ«ï¼š

1. å¤šäº†"å…±åŒæ¨æ–­"çš„æ­¥éª¤
2. å°‘äº†"ç‰ˆæœ¬è½¬åŒ–"çš„æ­¥éª¤

å¯¹äºå¤šå‡ºçš„"å…±åŒæ¨æ–­"æ­¥éª¤å…¶å®æ˜¯å®¹æ˜“ç†è§£çš„ï¼Œæ¯•ç«Ÿæ­¤æ—¶`Decode()`æ–¹æ³•ç­¾åå·²"ä»Šæ—¶ä¸åŒå¾€æ—¥"â€”â€”ä¸‰ä¸ªå‚æ•°å…¨éƒ¨åŒ…å«æœ‰GVKä¿¡æ¯ã€‚ å¯æ˜¯ä¸ºä»€ä¹ˆåœ¨è§£ç è¿‡ç¨‹ä¸­ä¸å†æœ‰"ç‰ˆæœ¬è½¬åŒ–"æ­¥éª¤äº†å‘¢ï¼Ÿéš¾é“è¿™æ¬¡é‡æ„èˆå¼ƒäº†Kubernetesçš„"ç‰ˆæœ¬è½¬åŒ–"å—ï¼Ÿ

å…¶å®ä¸ç„¶ï¼ŒPRä½œè€…å…¶å®æœ‰æ„è€Œä¸ºä¹‹â€”â€”JSON/YAMLåºåˆ—åŒ–å™¨ä»…ç”¨äº**çº¯ç²¹**çš„åºåˆ—åŒ–/ååºåˆ—åŒ–ä»»åŠ¡ã€‚ çœŸæ­£å¸¦æœ‰ç‰ˆæœ¬è½¬åŒ–çš„åºåˆ—åŒ–å™¨å®ç°æ˜¯`codec`ï¼Œå®ƒæ‰€å®ç°çš„ä¹Ÿæ˜¯`Codec`æ¥å£ã€‚



<pre class="language-go"><code class="lang-go"><strong>// pkg/runtime/serializer/versioning/versioning.go
</strong><strong>type codec struct {
</strong>	encoder   runtime.Encoder
	decoder   runtime.Decoder
	convertor runtime.ObjectConvertor
	creater   runtime.ObjectCreater
	typer     runtime.ObjectTyper
	defaulter runtime.ObjectDefaulter

	encodeVersion runtime.GroupVersioner
	decodeVersion runtime.GroupVersioner

	identifier runtime.Identifier

	// originalSchemeName is optional, but when filled in it holds the name of the scheme from which this codec originates
	originalSchemeName string
}
</code></pre>



* `convertor`æˆå‘˜ç”¨äº"ç‰ˆæœ¬è½¬åŒ–"æ­¥éª¤ï¼Œè¿™ä¸ªæˆå‘˜å¯ä»¥è®¤ä¸ºæ˜¯å‰¥ç¦»è‡ª"è¿‘ä»£"æ—¶æœŸçš„`Scheme`ä¸­çš„`convertor`ï¼›
* `creater`æˆå‘˜ç”¨äºæ ¹æ®ç»™å®šçš„GVKä¸‰å…ƒç»„åˆ›å»ºå¯¹åº”\_kind\_ï¼ˆAPIå¯¹è±¡ï¼‰çš„ç©ºå®ä¾‹ï¼ˆ"è½½ä½“"ï¼‰ï¼›
* `typer`æˆå‘˜ç”¨äºåˆ¤å®šä¸€ä¸ªç»™å®šçš„\_kind\_ï¼ˆAPIå¯¹è±¡ï¼‰æ˜¯å¦æ³¨å†Œè¿‡ï¼›
* `encodeVersion`å’Œ`decodeVersion`æˆå‘˜æ˜¯`codec`åºåˆ—åŒ–å™¨åŒºåˆ«äº"ç°ä»£"ï¼ˆ`Scheme`å¤§ä¸€ç»Ÿï¼‰æ—¶æœŸçš„ç¼–/è§£ç é€»è¾‘çš„å¦ä¸€ä¸ªç‰¹æ€§â€”â€”`codec`æ”¯æŒå°†ç‰ˆæœ¬è½¬åŒ–ä¸ºè°ƒç”¨è€…æŒ‡å®šçš„**ç›®æ ‡ç‰ˆæœ¬**ï¼Œè€Œä¸æ˜¯ä»…é»˜è®¤è½¬åŒ–ä¸ºå†…éƒ¨ç‰ˆæœ¬ã€‚

æ‰€ä»¥ï¼Œ`codec`åºåˆ—åŒ–å™¨æ˜¯å¯¹JSON/YAMLåºåˆ—åŒ–å™¨çš„è¿›ä¸€æ­¥å°è£…ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹çœ‹`codec`çš„è§£ç æ–¹æ³•çš„å…·ä½“æ­¥éª¤ï¼š

```go
// Decode attempts a decode of the object, then tries to convert it to the internal version. If into is provided and the decoding is
// successful, the returned runtime.Object will be the value passed as into. Note that this may bypass conversion if you pass an
// into that matches the serialized version.
func (c *codec) Decode(data []byte, defaultGVK *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
	// If the into object is unstructured and expresses an opinion about its group/version,
	// create a new instance of the type so we always exercise the conversion path (skips short-circuiting on `into == obj`)
	decodeInto := into
	if into != nil {
		if _, ok := into.(runtime.Unstructured); ok && !into.GetObjectKind().GroupVersionKind().GroupVersion().Empty() {
			decodeInto = reflect.New(reflect.TypeOf(into).Elem()).Interface().(runtime.Object)
		}
	}

	var strictDecodingErrs []error
	obj, gvk, err := c.decoder.Decode(data, defaultGVK, decodeInto)
	if err != nil {
		if strictErr, ok := runtime.AsStrictDecodingError(err); obj != nil && ok {
			// save the strictDecodingError and let the caller decide what to do with it
			strictDecodingErrs = append(strictDecodingErrs, strictErr.Errors()...)
		} else {
			return nil, gvk, err
		}
	}

	if d, ok := obj.(runtime.NestedObjectDecoder); ok {
		if err := d.DecodeNestedObjects(runtime.WithoutVersionDecoder{Decoder: c.decoder}); err != nil {
			if strictErr, ok := runtime.AsStrictDecodingError(err); ok {
				// save the strictDecodingError let and the caller decide what to do with it
				strictDecodingErrs = append(strictDecodingErrs, strictErr.Errors()...)
			} else {
				return nil, gvk, err

			}
		}
	}

	// aggregate the strict decoding errors into one
	var strictDecodingErr error
	if len(strictDecodingErrs) > 0 {
		strictDecodingErr = runtime.NewStrictDecodingError(strictDecodingErrs)
	}
	// if we specify a target, use generic conversion.
	if into != nil {
		// perform defaulting if requested
		if c.defaulter != nil {
			c.defaulter.Default(obj)
		}

		// Short-circuit conversion if the into object is same object
		if into == obj {
			return into, gvk, strictDecodingErr
		}

		if err := c.convertor.Convert(obj, into, c.decodeVersion); err != nil {
			return nil, gvk, err
		}

		return into, gvk, strictDecodingErr
	}

	// perform defaulting if requested
	if c.defaulter != nil {
		c.defaulter.Default(obj)
	}

	out, err := c.convertor.ConvertToVersion(obj, c.decodeVersion)
	if err != nil {
		return nil, gvk, err
	}
	return out, gvk, strictDecodingErr
}
```

1. åˆ©ç”¨åŸºç¡€çš„ JSON/YAMLåºåˆ—åŒ–ç»„ä»¶è¿›è¡Œçº¯ç²¹çš„ååºåˆ—åŒ–æ­¥éª¤ã€‚
2. ç‰ˆæœ¬è½¬åŒ–
   * å¦‚æœè°ƒç”¨è¿™æä¾›äº†ç›®æ ‡APIå¯¹è±¡è½½ä½“`into`ï¼Œåˆ™å°†ä¸Šä¸€æ­¥ååºåˆ—åŒ–ç»“æœè½¬åŒ–ä¸ºè°ƒç”¨è€…æä¾›çš„`into`å¯¹è±¡ï¼›
   * å¦‚æœè°ƒç”¨è€…æ²¡æœ‰æä¾›ç›®æ ‡APIå¯¹è±¡è½½ä½“ï¼ˆ`into`ä¸º`nil`ï¼‰ï¼Œå¹¶ä¸”äº‹å…ˆæä¾›äº†ç›®æ ‡ç‰ˆæœ¬çš„GVä¿¡æ¯ï¼ˆ`decodeVersion`ï¼‰åˆ™è½¬åŒ–ä¸ºæŒ‡å®šçš„ç›®æ ‡ç‰ˆæœ¬ï¼›
   * å¦‚æœè°ƒç”¨è€…å³æ²¡æœ‰æä¾›ç›®æ ‡APIå¯¹è±¡è½½ä½“ï¼ˆ`into`ä¸º`nil`ï¼‰ï¼Œä¹Ÿæ²¡æœ‰æä¾›ç›®æ ‡ç‰ˆæœ¬çš„GVä¿¡æ¯ï¼ˆ`decodeVersion`æˆå‘˜ä¸º`nil`ï¼‰åˆ™å°†ä¸Šä¸€æ­¥ååºåˆ—åŒ–çš„ç»“æœé»˜è®¤è½¬åŒ–ä¸ºå†…éƒ¨ç‰ˆæœ¬ã€‚

### CodecFactory

æˆ‘ä»¬ç°åœ¨å·²ç»çŸ¥é“`codec`åºåˆ—åŒ–å™¨æä¾›äº†è®¸å¤šå¯å®šåˆ¶åŒ–é¡¹ã€‚ä¾‹å¦‚å¯ä»¥é…ç½® JSON æˆ–è€… YAML ä½œä¸ºåº•å±‚çš„åºåˆ—åŒ–/ååºåˆ—åŒ–ç»„ä»¶ï¼Œä¹Ÿå¯ä»¥äº‹å…ˆé…ç½®å¥½æ‰€è¦è½¬åŒ–çš„ç›®æ ‡ç‰ˆæœ¬ä¿¡æ¯ã€‚ å› æ­¤ï¼Œåœ¨è¯¥PRä¸­ï¼Œä½œè€…ä¹ŸåŒæ—¶æä¾›äº†`CodecFactory`ï¼ˆ_åºåˆ—åŒ–å™¨å·¥å‚_ï¼‰â€”â€”ç”¨äº"ç”Ÿäº§"ä¸åŒå®šåˆ¶åŒ–çš„`codec`ã€‚

```go
// CodecFactory provides methods for retrieving codecs and serializers for specific
// versions and content types.
type CodecFactory struct {
	scheme    *runtime.Scheme
	universal runtime.Decoder
	accepts   []runtime.SerializerInfo

	legacySerializer runtime.Serializer
}
```

å…¶ä¸­ï¼š

* `scheme`æˆå‘˜ç”¨äº"APIå¯¹è±¡æ³¨å†Œ"ï¼›
* `accepts`æˆå‘˜ç”¨äºå­˜æ”¾**æ”¯æŒ**çš„ç¼–/è§£ç æ ¼å¼ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼š`"application/json"`ä»¥åŠ`"application/yaml"`;
* `universal`æˆå‘˜æ„åœ¨æä¾›ä¸€ä¸ª**é€šç”¨**å¿«æ·çš„è§£ç å™¨ï¼Œå®ƒèƒ½å¤Ÿè¯†åˆ«å­—èŠ‚åºåˆ—çš„æ•°æ®æ ¼å¼ï¼ˆJSON/YAMLï¼‰å†æ‰¾åˆ°å¯¹åº”çš„åŸºç¡€çš„åºåˆ—åŒ–å™¨è¿›è¡Œååºåˆ—åŒ–ã€‚

å¦å¤–ï¼Œ`CodecFactory`å…¶å®å®ç°äº†`NegotiatedSerializer`ï¼ˆ\_åå•†åºåˆ—åŒ–å™¨\_æ¥å£ï¼‰:

```go
var _ runtime.NegotiatedSerializer = &CodecFactory{}

// SupportedMediaTypes returns the RFC2046 media types that this factory has serializers for.
func (f CodecFactory) SupportedMediaTypes() []string {
    return f.accepts
}

// DecoderToVersion returns a decoder that targets the provided group version.
func (f CodecFactory) DecoderToVersion(serializer runtime.Serializer, gv unversioned.GroupVersion) runtime.Decoder {
    return f.CodecForVersions(serializer, nil, []unversioned.GroupVersion{gv})
}

// EncoderForVersion returns an encoder that targets the provided group version.
func (f CodecFactory) EncoderForVersion(serializer runtime.Serializer, gv unversioned.GroupVersion) runtime.Encoder {
    return f.CodecForVersions(serializer, []unversioned.GroupVersion{gv}, nil)
}
```

å®ƒå®ç°çš„`NegotiatedSerializer`æ¥å£çš„æ–¹æ³•ï¼š

* `SupportedMediaTypes()`æ–¹æ³•ç”¨äºè¿”å›æ‰€æ”¯æŒçš„ç¼–ç æ ¼å¼ï¼›
* `EncoderForVersion()/DecoderToVersion()`æ–¹æ³•ç”¨äº"ç”Ÿäº§"ä¸€ä¸ªå¯ä»¥è½¬åŒ–ä¸ºæŒ‡å®šç›®æ ‡ç‰ˆæœ¬çš„"å®šåˆ¶åŒ–"`codec`ï¼›

**åˆ›å»ºCodecFactoryå¯¹è±¡**

ä»‹ç»å®Œ`CodecFactory`ç±»å‹åï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å†æ¥çœ‹çœ‹å¦‚ä½•åˆ›å»ºä¸€ä¸ª`CodecFactory`ç±»ï¼š

```go
// NewCodecFactory provides methods for retrieving serializers for the supported wire formats
// and conversion wrappers to define preferred internal and external versions. In the future,
// as the internal version is used less, callers may instead use a defaulting serializer and
// only convert objects which are shared internally (Status, common API machinery).
//
// Mutators can be passed to change the CodecFactoryOptions before construction of the factory.
// It is recommended to explicitly pass mutators instead of relying on defaults.
// By default, Pretty is enabled -- this is conformant with previously supported behavior.
//
// TODO: allow other codecs to be compiled in?
// TODO: accept a scheme interface
func NewCodecFactory(scheme *runtime.Scheme, mutators ...CodecFactoryOptionsMutator) CodecFactory {
	options := CodecFactoryOptions{Pretty: true}
	for _, fn := range mutators {
		fn(&options)
	}

	serializers := newSerializersForScheme(scheme, json.DefaultMetaFactory, options)
	return newCodecFactory(scheme, serializers)
}
```

å¼€å‘è€…ä¸ºæˆ‘ä»¬å°è£…çš„åˆå§‹åŒ–å‡½æ•°ååˆ†ç®€å•â€”â€”è°ƒç”¨è€…ä»…éœ€è¦æä¾›ä¸€ä¸ª`Scheme`å¯¹è±¡å³å¯ï¼Œå‰©ä¸‹çš„ç”±åˆå§‹åŒ–å‡½æ•°å®Œæˆã€‚

#### **WithoutConversion**

æˆ‘ä»¬çŸ¥é“"ç‰ˆæœ¬è½¬åŒ–"åœ¨`kube-apiserver`æ˜¯ä¸ªååˆ†é‡è¦çš„è¡Œä¸ºã€‚ä½†æ˜¯å¯¹äºå®¢æˆ·ç«¯ï¼ˆ`client-go`ï¼‰æ¥è¯´ï¼Œå®ƒä»¬åœ¨åºåˆ—åŒ–/ååºåˆ—åŒ–èµ„æºæ—¶å…¶å®å¹¶ä¸éœ€è¦"ç‰ˆæœ¬è½¬åŒ–"ã€‚ é’ˆå¯¹è¿™ç§éœ€æ±‚ï¼Œåœ¨[Kubernetes v1.15.0-alpha1](https://github.com/kubernetes/kubernetes/tree/v1.15.0-alpha1) [Pull Request #76098](https://github.com/kubernetes/kubernetes/pull/76098) å¼€å‘è€…ç»™`CodecFactory`å°è£…äº†ä¸€ä¸ª"å¿«æ·"æ–¹æ³•`WithoutConversion()`ï¼š

<pre class="language-go"><code class="lang-go">// WithoutConversion returns a NegotiatedSerializer that performs no conversion
<strong>// ç”¨äºè¿”å›ä¸€ä¸ªåœ¨ç¼–/è§£ç æ—¶ä¸è¿›è¡Œç‰ˆæœ¬è½¬åŒ–çš„CodecFactoryã€‚
</strong><strong>func (f CodecFactory) WithoutConversion() runtime.NegotiatedSerializer {
</strong>    // ...
}
</code></pre>

#### ParameterCodec

ä¸Šè¿°çš„`CodecFactory`ä¸»è¦ç”¨äºHTTP**è¯·æ±‚/è¿”å›ä½“**ï¼ˆå³\_èµ„æº\_ï¼‰çš„ç¼–è§£/ç ã€‚

åœ¨ææ¡ˆ [Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111) ä¸­ï¼Œä½œè€…ç”šè‡³ "è´´å¿ƒåœ°" æè®®ä¸ºHTTP URLå‚æ•°ï¼ˆQuery Parametersï¼‰ä¸Goå¯¹è±¡ä¹‹é—´çš„è½¬æ¢ä¹Ÿä¸“é—¨å°è£…æˆä¸€ç§"ç¼–è§£ç å™¨"ï¼š

> There are places where we want to convert map\[string]interface{} (generic JSON object representation) or a map\[string]\[]string (url.Values) into a versioned Go struct, which is dependent on a type of marshaling (i.e. following JSON rules, or Query parameter rules).

åœ¨ [Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922) ä¸­ï¼Œä½œè€…å®ç°äº†`ParameterCodec`ç¼–è§£ç å™¨ä¸“é—¨ç”¨äºæ­¤ç›®çš„ï¼š

```go
// parameterCodec implements conversion to and from query parameters and objects.
type parameterCodec struct {
	typer     ObjectTyper
	convertor ObjectConvertor
	creator   ObjectCreater
	defaulter ObjectDefaulter
}
```

ä¾‹å¦‚ï¼Œé€šå¸¸æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`apimachinery`åº“æä¾›çš„ `metav1.ListOptions` ç»“æ„æ¥åŸºäºæ¡ä»¶åœ°æŸ¥è¯¢èµ„æºé›†åˆï¼š

```go
listOptions := metav1.ListOptions{
        Limit: 1,
        LabelSelector: "app=foo",
    }
pods, _ := clientset.CoreV1().Pods("default").List(listOptions)
```

`client-go`å…¶å®åœ¨èƒŒåæ­£æ˜¯åˆ©ç”¨äº†`ParameterCodec`"ç¼–è§£ç å™¨"å°†`metav1.ListOptions`ç±»å‹æœ€ç»ˆ"è§£ç "æˆ HTTP URLå‚æ•°`limit=1&app=foo`ã€‚ å¦å¤–ï¼Œéœ€è¦æåŠçš„æ˜¯ï¼Œ`ParameterCodec`"ç¼–è§£ç å™¨"ä»ç„¶åŸºäº`Scheme`æ³¨å†Œæœºåˆ¶å·¥ä½œï¼ˆ`typer`å’Œ`creator`æˆå‘˜ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ`metav1.ListOptions`ç±»å‹ä¹ŸåŒæ ·éœ€è¦æ³¨å†Œè¿›`scheme`ä¸­ã€‚

## å°ç»“



åœ¨æœ¬å°èŠ‚ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆå¼ºè°ƒäº†åœ¨Kubernetesä¸Šä¸‹æ–‡ä¸­ç¼–/è§£ç çš„ç‰¹æ®Šæ€§ï¼Œè€Œè¿™ç§ç‰¹æ®Šæ€§æœ¬è´¨ä¸Šæ¥è‡ªäºèµ„æºçš„å¤šç‰ˆæœ¬ä»¥åŠç‰ˆæœ¬é—´çš„ç›¸äº’è½¬åŒ–ã€‚ ä¹‹åæˆ‘ä»¬æ€»ç»“äº†Kubernetesç¼–/è§£ç ä½“ç³»æ¼”åŒ–çš„å››ä¸ªé‡è¦é˜¶æ®µã€‚ å¦‚ä»Šçš„Kubernetesä½“ç³»ä¸»è¦åŸºäºä¸¤ä¸ªç»„ä»¶ï¼š

* `Scheme`â€”â€”\_kind\_æ³¨å†Œ
* `codec`â€”â€”åºåˆ—åŒ–/ååºåˆ—åŒ–åŠèµ„æºç‰ˆæœ¬è½¬åŒ–

å¦å¤–ï¼Œæˆ‘ä»¬è¿˜ä»‹ç»äº†`CodecFactory`ï¼Œå®ƒå®ç°äº†`NegotiatedSerializer`ï¼ˆ_åå•†åºåˆ—åŒ–å™¨_ï¼‰ï¼Œæ”¯æŒå¤šç§ç¼–ç æ ¼å¼ï¼Œä¹Ÿå¯ä»¥ç”¨äºç”Ÿäº§"å®šåˆ¶åŒ–"çš„`codec`ã€‚

åŒæ—¶æˆ‘ä»¬ä¹ŸæŒ‡å‡ºäº†å¯¹äºå®¢æˆ·ç«¯æ¥è¯´ï¼Œå®ƒåœ¨åºåˆ—åŒ–/ååºåˆ—åŒ–èµ„æºæ—¶å¹¶ä¸éœ€è¦åƒKubernetes API Serverä¸€æ ·è¿›è¡Œç‰ˆæœ¬è½¬ã€‚é’ˆå¯¹è¿™ç§éœ€æ±‚ï¼Œ`CodecFactory`çš„`WithoutConversion()`æ–¹æ³•ä¹Ÿå¯¹æ­¤æä¾›äº†æ–¹ä¾¿å¿«æ·çš„æ”¯æŒã€‚
