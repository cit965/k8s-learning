# 5.3 api-conventions（翻译）

_本文档面向想要深入了解 Kubernetes API 结构的用户以及想要扩展 Kubernetes API 的开发者。有关通过 kubectl 使用资源的介绍可以在_[_对象管理概述_](https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/)_中找到。_

&#x20;**目录**

* &#x20;[类型（种类）](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#types-kinds)
  * &#x20;[资源](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#resources)
  * &#x20;[对象](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#objects)
    * &#x20;[元数据](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#metadata)
    * &#x20;[规格和状态](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#spec-and-status)
      * [典型状态属性](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#typical-status-properties)
    * [对相关对象的引用](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#references-to-related-objects)
    * [优先于地图的命名子对象列表](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#lists-of-named-subobjects-preferred-over-maps)
    * &#x20;[原始类型](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#primitive-types)
    * &#x20;[常数](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#constants)
    * &#x20;[工会](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#unions)
  * &#x20;[列表和简单类型](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#lists-and-simple-kinds)
* [不同的表示](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#differing-representations)
* &#x20;[资源动词](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#verbs-on-resources)
  * &#x20;[补丁操作](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#patch-operations)
* [简称和类别](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#short-names-and-categories)
  * &#x20;[简称](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#short-names)
  * &#x20;[类别](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#categories)
* &#x20;[幂等性](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#idempotency)
* &#x20;[可选与必需](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#optional-vs-required)
* &#x20;[违约](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#defaulting)
  * &#x20;[静态默认值](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#static-defaults)
  * [准入控制默认值](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#admission-controlled-defaults)
  * [控制器分配的默认值（又名后期初始化）](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#controller-assigned-defaults-aka-late-initialization)
  * &#x20;[什么可能被违约](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#what-may-be-defaulted)
  * [PUT 操作的注意事项](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#considerations-for-put-operations)
* [并发控制和一致性](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#concurrency-control-and-consistency)
* &#x20;[序列化格式](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#serialization-format)
* &#x20;[单位](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#units)
* &#x20;[选择字段](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#selecting-fields)
* &#x20;[对象引用](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#object-references)
  * [参考字段的命名](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#naming-of-the-reference-field)
  * [引用多个版本的资源](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#referencing-resources-with-multiple-versions)
  * [处理不存在的资源](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#handling-of-resources-that-do-not-exist)
  * &#x20;[字段验证](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#validation-of-fields)
  * [不要修改引用的对象](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#do-not-modify-the-referred-object)
  * [最小化复制或打印引用对象的值](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#minimize-copying-or-printing-values-to-the-referrer-object)
  * [对象引用示例](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#object-references-examples)
    * [单一资源参考](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#single-resource-reference)
      * &#x20;[控制器行为](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#controller-behavior)
    * [多种资源参考](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#multiple-resource-reference)
      * &#x20;[种类与资源](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#kind-vs-resource)
      * &#x20;[控制器行为](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#controller-behavior-1)
    * &#x20;[通用对象引用](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#generic-object-reference)
      * &#x20;[控制器行为](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#controller-behavior-2)
    * &#x20;[现场参考](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#field-reference)
      * &#x20;[控制器行为](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#controller-behavior-3)
* &#x20;[HTTP 状态代码](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#http-status-codes)
  * &#x20;[成功代码](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#success-codes)
  * &#x20;[错误代码](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#error-codes)
* &#x20;[响应状态类型](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#response-status-kind)
* &#x20;[活动](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#events)
* &#x20;[命名约定](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#naming-conventions)
  * &#x20;[命名空间名称](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#namespace-names)
* [标签、选择器和注释约定](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#label-selector-and-annotation-conventions)
* &#x20;[WebSocket 和 SPDY](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#websockets-and-spdy)
* &#x20;[验证](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#validation)
* [自动资源分配和释放](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#automatic-resource-allocation-and-deallocation)
* [代表分配值](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#representing-allocated-values)
  * [何时使用`spec`字段](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#when-to-use-a-spec-field)
  * [何时使用`status`字段](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#when-to-use-a-status-field)
    * &#x20;[排序操作](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#sequencing-operations)
  * [何时使用不同类型](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#when-to-use-a-different-type)

[Kubernetes API](https://kubernetes.io/docs/concepts/overview/kubernetes-api/) （以及生态系统中的相关 API）的约定旨在简化客户端开发，并确保可以实现跨不同用例集一致工作的配置机制。

Kubernetes API 的一般风格是 RESTful - 客户端通过标准 HTTP 动词（POST、PUT、DELETE 和 GET）创建、更新、删除或检索对象的描述 - 并且这些 API 优先接受并返回 JSON。 Kubernetes 还公开了非标准动词的附加端点，并允许替代内容类型。服务器接受和返回的所有 JSON 都有一个架构，由“kind”和“apiVersion”字段标识。如果存在相关的 HTTP 标头字段，它们应该镜像 JSON 字段的内容，但信息不应仅在 HTTP 标头中表示。

定义了以下术语：

* **指定**特定对象模式的名称（例如“Cat”和“Dog”类型将具有不同的属性和特性）
* **资源**系统实体的表示，以 JSON 形式发送或检索 通过 HTTP 到服务器。资源通过以下方式公开：
  * 集合 - 相同类型的资源列表，可以查询
  * 元素 - 单个资源，可通过 URL 寻址
* **API 将**一组公开的资源分组，以及“apiVersion”字段中公开的版本作为“GROUP/VERSION”，例如“policy.k8s.io/v1”。

每个资源通常接受并返回单一类型的数据。反映特定用例的多个资源可以接受或返回一种类型。例如，“Pod”类型作为“pod”资源公开，允许最终用户创建、更新和删除 Pod，而单独的“Pod 状态”资源（作用于“Pod”类型）允许自动化流程更新该资源中的字段子集。

资源在 API 组中绑定在一起 - 每个组可能有一个或多个独立于其他 API 组发展的版本，并且组内的每个版本都有一个或多个资源。组名称通常采用域名形式 - Kubernetes 项目保留使用空组、所有单字名称（“扩展名”、“应用程序”）以及任何以“\*.k8s.io”结尾的组名称仅供其单独使用。选择群组名称时，我们建议选择您的群组或组织拥有的子域，例如“widget.mycompany.com”。

版本字符串应与[DNS\_LABEL](https://git.k8s.io/design-proposals-archive/architecture/identifiers.md)格式匹配。

资源集合应全部小写且复数，而种类则应采用驼峰式命名且单数。组名称必须是小写且是有效的 DNS 子域。

### &#x20;类型（种类）

种类分为三类：

1.  **对象**代表系统中的持久实体。

    创建 API 对象是意图的记录 - 一旦创建，系统将努力确保资源存在。所有 API 对象都有共同的元数据。

    一个对象可能具有多个资源，客户端可以使用这些资源来执行创建、更新、删除或获取等特定操作。

    示例： `Pod` 、 `ReplicationController` 、 `Service` 、 `Namespace` 、 `Node` 。
2.  **列表**是一种（通常）或多种（偶尔）类型的**资源**的集合。

    列表类型的名称必须以“List”结尾。列表具有一组有限的公共元数据。所有列表都使用必需的“items”字段来包含它们返回的对象数组。任何具有“items”字段的类型都必须是列表类型。

    系统中定义的大多数对象应该有一个返回完整资源集的端点，以及零个或多个返回完整列表子集的端点。有些对象可能是单例（当前用户，系统默认）并且可能没有列表。

    此外，所有返回带有标签的对象的列表都应支持标签过滤（请参阅[标签文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/)），并且大多数列表应支持按字段过滤（请参阅[字段文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/)）。

    示例： `PodList` 、 `ServiceList` 、 `NodeList` 。

请注意， `kubectl`和其他工具有时会以`kind: List`输出资源集合。请记住这`kind: List`不是 Kubernetes API 的一部分；它是 Kubernetes API 的一部分。它公开了这些工具中客户端代码的实现细节，用于处理混合资源组。

3.  **简单**类型用于对对象和非持久实体的特定操作。

    鉴于其范围有限，它们具有与列表相同的有限公共元数据集。

    例如，“状态”类型在发生错误时返回，并且不会保留在系统中。

    许多简单的资源都是“子资源”，它们植根于特定资源的API路径。当资源希望公开与单个资源紧密耦合的替代操作或视图时，它们应该使用新的子资源来实现。常见的子资源包括：

    * `/binding` ：用于将表示用户请求的资源（例如，Pod、PersistentVolumeClaim）绑定到集群基础设施资源（例如，Node、PersistentVolume）。
    * `/status` ：用于仅写入资源的`status`部分。例如， `/pods`端点仅允许更新`metadata`和`spec` ，因为它们反映了最终用户的意图。自动化流程应该能够通过将更新的 Pod 类型发送到服务器的“/pods/”来修改状态以供用户查看。 /status”端点 - 备用端点允许对更新应用不同的规则，并适当限制访问。
    * `/scale` ：用于以独立于特定资源模式的方式读取和写入资源的计数。

    两个附加子资源`proxy`和`portforward`提供对集群资源的访问，如[访问集群](https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/)中所述。

标准 REST 动词（定义如下）必须返回单数 JSON 对象。某些 API 端点可能会偏离严格的 REST 模式并返回不是单一 JSON 对象的资源，例如 JSON 对象流或非结构化文本日志数据。

所有 API 组都使用一组通用的“元”API 对象，因此被视为名为`meta.k8s.io`的 API 组的一部分。这些类型可能独立于使用它们的 API 组而发展，并且 API 服务器可能允许以通用形式对它们进行寻址。示例包括`ListOptions` 、 `DeleteOptions` 、 `List` 、 `Status` 、 `WatchEvent`和`Scale` 。由于历史原因，这些类型是每个现有 API 组的一部分。配额、垃圾收集、自动缩放器等通用工具和 kubectl 等通用客户端利用这些类型来定义跨不同资源类型的一致行为，例如编程语言中的接口。

术语“种类”是为这些“顶级”API 类型保留的。术语“类型”应用于区分对象或子对象内的子类别。

#### &#x20;资源

API 返回的所有 JSON 对象必须具有以下字段：

* kind：标识该对象应具有的架构的字符串
* apiVersion：标识对象应具有的模式版本的字符串

这些字段是正确解码对象所必需的。默认情况下，服务器可能会从指定的 URL 路径填充它们，但客户端可能需要知道这些值才能构造 URL 路径。

#### &#x20;对象

&#x20;**元数据**

每个对象类型必须在称为“元数据”的嵌套对象字段中具有以下元数据：

* 命名空间：命名空间是对象被细分的 DNS 兼容标签。默认命名空间是“default”。有关更多信息，请参阅[命名空间文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/)。
* name：在当前命名空间中唯一标识该对象的字符串（请参阅[标识符文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/)）。当检索单个对象时，该值在路径中使用。
* uid：时间和空间上的唯一值（通常是 RFC 4122 生成的标识符，请参阅[标识符文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/)），用于区分已删除和重新创建的同名对象

每个对象都应该在称为“元数据”的嵌套对象字段中具有以下元数据：

* ResourceVersion：标识该对象的内部版本的字符串，客户端可以使用该字符串来确定对象何时发生更改。该值必须被客户端视为不透明，并未经修改地传递回服务器。客户端不应假设资源版本在跨命名空间、不同类型的资源或不同服务器之间具有含义。 （有关更多详细信息，请参阅下面的[并发控制](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#concurrency-control-and-consistency)。）
* Generation：表示所需状态的特定代的序列号。由系统设置并按资源单调递增。可以进行比较，例如 RAW 和 WAW 的一致性。
* 创建时间戳：表示创建对象的日期和时间的 RFC 3339 日期的字符串
* 删除时间戳：一个字符串，表示 RFC 3339 日期和时间，在此之后将删除该资源。当用户请求正常删除时，该字段由服务器设置，并且客户端不能直接设置。在此字段中的时间之后，资源将被删除（不再从资源列表中可见，并且无法通过名称访问），除非对象设置了终结器。如果设置了终结器，则对象的删除至少会推迟到终结器被删除为止。一旦设置了deletionTimestamp，该值就不能被取消设置或在将来进一步设置，尽管它可能会被缩短或者资源可能会在该时间之前被删除。
* 标签：可用于组织和分类对象的字符串键和值的映射（请参阅[标签文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/)）
* 注释：字符串键和值的映射，外部工具可以使用它来存储和检索有关该对象的任意元数据（请参阅[注释文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/)）

标签供最终用户用于组织目的（选择与此标签查询匹配的 Pod）。注释使第三方自动化和工具能够使用附加元数据来装饰对象以供其自己使用。

&#x20;**规格和状态**

按照惯例，Kubernetes API 区分对象所需状态的规范（称为`spec`的嵌套对象字段）和对象当前的状态（称为`status`的嵌套对象字段）。该规范是对所需状态的完整描述，包括用户提供的配置设置、系统扩展的[默认值](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#defaulting)以及其他生态系统组件（例如调度程序、自动缩放程序）创建后初始化或更改的属性，并且使用 API 对象持久保存在稳定存储中。如果删除规范，该对象将从系统中清除。

`status`总结了系统中对象的当前状态，并且通常通过自动化过程与对象一起保存，但也可以动态生成。作为一般准则， `status`中的字段应该是对实际状态的最新观察，但它们可能包含诸如分配结果或响应对象`spec`而执行的类似操作之类的信息。请参阅[下文](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#representing-allocated-values)了解更多详细信息。

具有`spec`和`status`节的类型可以（并且通常应该）具有不同的授权范围。这允许用户被授予对`spec`的完全写访问权限和对状态的只读访问权限，而相关控制器被授予对`spec`的只读访问权限但对状态的完全写访问权限。

当发布或放置对象的新版本时， `spec`将立即更新并可用。随着时间的推移，系统将努力使`status`符合`spec` 。无论该节的先前版本如何，系统都将朝着最新的`spec` 。例如，如果在一个 PUT 中将值从 2 更改为 5，然后在另一 PUT 中又降回 3，则系统不需要在将`status`更改为 3 之前在 5 处“触及基础”。换句话说，系统的行为是\_基于水平的\_而不是\_基于边缘的\_。这使得在错过中间状态变化的情况下能够实现稳健的行为。

Kubernetes API 还充当系统声明性配置模式的基础。为了促进基于级别的操作和声明性配置的表达，规范中的字段应该具有声明性的而不是命令性的名称和语义——它们表示期望的状态，而不是旨在产生期望状态的操作。

对象上的 PUT 和 POST 动词必须忽略`status`值，以避免在读取-修改-写入场景中意外覆盖`status` 。必须提供`/status`子资源以使系统组件能够更新其管理的资源的状态。

否则，PUT 期望指定整个对象。因此，如果省略某个字段，则假定客户端想要清除该字段的值。 PUT 动词不接受部分更新。仅修改对象的一部分可以通过获取资源、修改部分规范、标签或注释，然后将其放回来实现。有关使用此模式时的读取-修改-写入一致性的信息，请参阅下面的[并发控制](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#concurrency-control-and-consistency)。某些对象可能会公开允许状态突变或对对象执行自定义操作的替代资源表示。

所有表示其状态可能与用户期望的意图不同的物理资源的对象都应该有一个`spec`和一个`status` 。其状态不能与用户期望的意图不同的对象可以只有`spec` ，并且可以将`spec`重命名为更合适的名称。

同时包含`spec`和`status`的对象不应包含除标准元数据字段之外的其他顶级字段。

一些未保留在系统中的对象（例如`SubjectAccessReview`和其他 webhook 样式调用）可能会选择添加`spec`和`status`来封装“调用和响应”模式。 `spec`是请求（通常是对信息的请求）， `status`是响应。对于这些类似 RPC 的对象，唯一的操作可能是 POST，但是在提交和响应之间具有一致的模式会降低这些客户端的复杂性。

**典型状态属性**

**条件**为控制器提供更高级别的状态报告提供标准机制。它们是一种扩展机制，允许工具和其他控制器收集有关资源的摘要信息，而无需了解特定于资源的状态详细信息。条件应该补充有关控制器编写的对象的观察状态的更详细信息，而不是取代它。例如，部署的“可用”条件可以通过检查`readyReplicas` 、 `replicas`和部署的其他属性来确定。但是，“可用”条件允许其他组件避免在部署控制器中重复可用性逻辑。

对象可以报告多种条件，并且将来或由第 3 方控制器可能添加新类型的条件。因此，条件是使用对象列表/切片来表示的，其中每个条件都具有相似的结构。该集合应被视为具有`type`为键的映射。

当条件遵循一些一致的约定时，它们是最有用的：

* 应添加条件以明确传达用户和组件关心的属性，而不是要求从其他观察中推断出这些属性。一旦定义，条件的含义就不能任意更改 - 它成为 API 的一部分，并且与 API 的任何其他部分具有相同的向后和向前兼容性问题。
* 控制器应在第一次访问资源时将其条件应用于资源，即使`status`为“未知”。这使得系统中的其他组件知道该情况存在并且控制器正在协调该资源方面取得进展。
  * 并非所有控制器都会遵守之前有关报告“未知”或“错误”值的建议。对于已知条件，不存在条件`status`应被解释为与`Unknown`相同，并且通常表示协调尚未完成（或者资源状态可能尚不可观察）。
* 对于某些情况， `True`表示正常操作，对于某些情况， `False`表示正常操作。 （“正常真”条件有时被称为具有“正极性”，“正常假”条件被称为具有“负极性”。）如果不进一步了解条件，就不可能计算通用摘要资源的条件。
* 条件类型名称应该对人类有意义；一般而言，正极性或负极性均不推荐。像“内存耗尽”这样的负面条件可能比“内存充足”更容易被人类理解。相反，“Ready”或“Succeeded”可能比“Failed”更容易理解，因为“Failed=Unknown”或“Failed=False”可能会导致双重否定混淆。
* 条件类型名称应该描述资源当前观察到的状态，而不是描述当前状态转换。这通常意味着名称应该是形容词（“Ready”、“OutOfDisk”）或过去时动词（“Succeeded”、“Failed”），而不是现在时动词（“Deploying”）。可以通过将条件的`status`设置为`Unknown`来指示中间状态。
  * 对于需要较长时间（例如超过1分钟）的状态转换，将转换本身视为观察状态是合理的。在这些情况下，条件（例如“调整大小”）本身不应是瞬态的，而应使用`True` / `False` / `Unknown`模式来发出信号。这允许其他观察者确定来自控制器的最后更新，无论成功还是失败。如果状态转换无法完成并且继续协调不可行，则应使用原因和消息来指示转换失败。
* 在设计资源的条件时，拥有一个总结了更详细条件的通用顶级条件会很有帮助。简单的消费者可以简单地查询顶级条件。尽管它们不是一致的标准，但 API 设计者可以将`Ready`和`Succeeded`条件类型分别用于长时间运行和有界执行对象。

条件应遵循[k8s.io/apimachinery/pkg/apis/meta/v1/types.go](https://github.com/kubernetes/apimachinery/blob/release-1.23/pkg/apis/meta/v1/types.go#L1432-L1492)中包含的标准架构。它应该作为状态中的顶级元素包含在内，类似于

```go
// +listType=map
// +listMapKey=type
// +patchStrategy=merge
// +patchMergeKey=type
// +optional
Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
```

`metav1.Conditions`包含以下字段

```go
// type of condition in CamelCase or in foo.example.com/CamelCase.
// +required
Type string `json:"type" protobuf:"bytes,1,opt,name=type"`
// status of the condition, one of True, False, Unknown.
// +required
Status ConditionStatus `json:"status" protobuf:"bytes,2,opt,name=status"`
// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
// +optional
ObservedGeneration int64 `json:"observedGeneration,omitempty" protobuf:"varint,3,opt,name=observedGeneration"`
// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
// +required
LastTransitionTime Time `json:"lastTransitionTime" protobuf:"bytes,4,opt,name=lastTransitionTime"`
// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
// +required
Reason string `json:"reason" protobuf:"bytes,5,opt,name=reason"`
// message is a human readable message indicating details about the transition.
// This may be an empty string.
// +required
Message string `json:"message" protobuf:"bytes,6,opt,name=message"`
```

将来可能会添加其他字段。

需要使用`Reason`字段。

条件类型应以 PascalCase 命名。首选条件名称短（例如“Ready”而不是“MyResourceReady”）。

条件`status`值可能是`True` 、 `False`或`Unknown` 。不存在条件应被解释为与`Unknown`相同。控制器如何处理`Unknown`取决于相关条件。

围绕条件的思考随着时间的推移而不断发展，因此有一些广泛使用的非规范示例。

一般来说，条件值可能会来回变化，但某些条件转换可能是单调的，具体取决于资源和条件类型。然而，条件是观察结果，而不是状态机，我们也没有为对象定义全面的状态机，也没有定义与状态转换相关的行为。该系统是基于关卡的，而不是边缘触发的，并且应该假设一个开放世界。

振荡条件类型的一个示例是`Ready` ，它表示对象在上次探测时被认为是完全可操作的。可能的单调条件可能会`Succeeded` 。 `Succeeded`状态为`True`意味着已完成并且资源不再处于活动状态。仍处于活动状态的对象通常会具有状态为`Unknown` `Succeeded`条件。

v1 API 中的某些资源包含称为\*\*`phase`\*\*的字段以及关联的`message` 、 `reason`和其他状态字段。使用`phase`的模式已被弃用。较新的 API 类型应改用条件。 Phase 本质上是一个状态机枚举字段，它与[系统设计原则](https://git.k8s.io/design-proposals-archive/architecture/principles.md#control-logic)相矛盾并阻碍了演化，因为[添加新的枚举值会破坏向后兼容性](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md)。我们不鼓励客户从阶段推断隐式属性，而是更愿意明确公开客户需要监控的个别条件。条件还有一个好处，即可以创建一些在所有资源类型中具有统一含义的条件，同时仍然公开特定资源类型特有的其他条件。有关更多详细信息和讨论，请参阅[#7856](http://issues.k8s.io/7856) 。

在条件类型以及 API 中出现的其他任何地方， \*\*`Reason`**旨在成为当前状态原因类别的单字驼峰式表示形式，而**`Message`\*\*旨在成为人类可读的短语或句子，其中可能包含个别事件的具体细节。 `Reason`旨在用于简洁的输出，例如单行`kubectl get`输出，以及总结发生的原因，而`Message`旨在以详细的状态说明形式呈现给用户，例如`kubectl describe`输出。

历史信息状态（例如，上次转换时间、失败计数）仅在合理的努力下提供，并且不保证不会丢失。

可能很大（特别是与其他资源集合的大小成比例，例如对其他对象的引用列表 - 见下文）和/或快速变化的状态信息，例如[资源使用情况](https://git.k8s.io/design-proposals-archive/scheduling/resources.md#usage-data)，应该放入单独的对象中，可能来自原始对象的引用。这有助于确保 GET 和监视对于大多数可能不需要该数据的客户端保持相当高效。

一些资源报告`observedGeneration` ，这是负责根据资源所需状态的更改采取行动的组件最近观察到的`generation` 。例如，这可用于确保报告的状态反映最新的所需状态。

**对相关对象的引用**

对松散耦合对象集的引用（例如由[复制控制器](https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/)监督的[Pod](https://kubernetes.io/docs/concepts/workloads/pods/) ）通常最好使用[标签选择器](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors)来引用。为了确保各个对象的 GET 在时间和空间上保持有限，可以通过单独的 API 查询来查询这些集合，但不会在引用对象的状态中扩展。

有关特定对象的引用，请参阅[对象引用](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#object-references)。

当引用是一对一的并且不需要频繁更新时，特别是以基于边缘的方式，可以允许引用者的`status`对引用者的引用。

**优先于地图的命名子对象列表**

在[#2004](http://issue.k8s.io/2004)和其他地方讨论过。任何 API 对象中都没有子对象的映射。相反，约定是使用包含名称字段的子对象列表。 Kubernetes[文档](https://kubernetes.io/docs/reference/using-api/server-side-apply/#merge-strategy)中更详细地描述了这些约定以及如何更改列表、结构和映射的语义。

&#x20;例如：

```yaml
ports:
  - name: www
    containerPort: 80
```

&#x20;与

```yaml
ports:
  www:
    containerPort: 80
```

此规则保持了所有 JSON/YAML 键都是 API 对象中的字段的不变性。唯一的例外是 API 中的纯映射（当前为标签、选择器、注释、数据），而不是子对象集。

&#x20;**原始类型**

* 查看 API 中的类似字段（例如端口、持续时间）并遵循现有字段的约定。
* 不要使用枚举。使用字符串的别名（例如`NodeConditionType` ）。
* 所有数字字段都应该进行边界检查，无论是太小或负数还是太大。
* 所有公共整数字段必须使用 Go `int32`或 Go `int64`类型，而不是`int` （其大小不明确，具体取决于目标平台）。内部类型可以使用`int` 。
* 对于整数字段，优先选择`int32`而不是`int64`除非您需要表示大于`int32`的值。请参阅有关`int64`限制和语言兼容性的其他指南。
* 不要使用无符号整数，因为不同语言和库的支持不一致。如果是这种情况，只需验证该整数是否为非负数即可。
* 所有数字（例如`int32` 、 `int64` ）都会被 Javascript 和其他一些语言转换为`float64` ，因此任何预计在大小或精度上超过该值的字段（例如整数值 > 53 位）都应该被序列化并接受为字符串。 `int64`字段必须进行边界检查，使其在`-(2^53) < x < (2^53)`范围内。
* 尽可能避免浮点值，并且永远不要在规范中使用它们。浮点值无法在不改变的情况下可靠地往返（编码和重新解码），并且在不同语言和体系结构中具有不同的精度和表示形式。
* 对于`bool`字段要三思而后行。许多想法都是从布尔值开始的，但最终趋向于一小组相互排斥的选项。通过将策略选项显式描述为字符串类型别名（例如`TerminationMessagePolicy` ）来规划未来的扩展。

&#x20;**常数**

某些字段将具有允许值（枚举）的列表。这些值将是字符串，并且采用驼峰式命名法，首字母大写。示例： `ClusterFirst` 、 `Pending` 、 `ClientIP` 。当使用首字母缩略词或首字母缩写词时，首字母缩略词中的每个字母都应为大写，例如`ClientIP`或`TCPDelay` 。当专有名称或命令行可执行文件的名称用作常量时，专有名称应以一致的大小写表示 - 例如： `systemd` 、 `iptables` 、 `IPVS` 、 `cgroupfs` 、 `Docker` （作为通用概念）、 `docker` （作为命令行可执行文件）。如果使用像`eBPF`这样混合大小写的专有名称，则应将其保留在更长的常量中，例如`eBPFDelegation` 。

Kubernetes 中的所有 API 都必须利用这种风格的常量，包括标志和配置文件。如果以前使用了不一致的常量，则新标志应仅采用驼峰命名法，并且随着时间的推移，应更新旧标志以接受驼峰命名法值以及不一致的常量。示例：Kubelet 接受`--topology-manager-policy`标志，其值为`none` 、 `best-effort` 、 `restricted`和`single-numa-node` 。此标志应该接受`None` 、 `BestEffort` 、 `Restricted`和`SingleNUMANode` 。如果将新值添加到标志中，则应支持两种形式。

&#x20;**工会**

有时，最多可以设置一组字段中的一个。例如，PodSpec 的 \[volumes] 字段有 17 个不同的卷类型特定字段，例如`nfs`和`iscsi` 。集合中的所有字段都应该是[可选的](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#optional-vs-required)。

有时，当创建一种新类型时，api 设计者可能会预计将来需要联合，即使最初只允许一个字段。在这种情况下，请务必将该字段设置[为可选。](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#optional-vs-required)在验证中，如果未设置唯一字段，您仍然可能会返回错误。不要为该字段设置默认值。

#### &#x20;列表和简单类型

每个列表或简单类型都应该在称为“元数据”的嵌套对象字段中具有以下元数据：

* ResourceVersion：一个字符串，标识列表中返回的对象的通用版本。该值必须被客户端视为不透明，并未经修改地传递回服务器。资源版本仅在单一类型资源的单一命名空间内有效。

服务器返回的每个简单类型以及发送到服务器的任何必须支持幂等性或乐观并发的简单类型都应返回此值。由于简单资源经常用作修改对象的输入替代操作，因此简单资源的资源版本应该与对象的资源版本相对应。

### 不同的表示

API 可以针对不同的客户端以不同的方式表示单个实体，或者在系统中发生某些转换后转换对象。在这些情况下，一个请求对象可能有两种可用作不同资源或不同种类的表示形式。

一个例子是服务，它代表用户将一组在公共端口上具有公共行为的 Pod 分组的意图。当 Kubernetes 检测到某个 pod 与服务选择器匹配时，该 pod 的 IP 地址和端口将添加到该服务的 Endpoints 资源中。 Endpoints 资源仅在 Service 存在时才存在，但仅公开所选 Pod 的 IP 和端口。完整的服务由两个不同的资源表示 - 在用户创建的原始服务资源下以及端点资源中。

作为另一个示例，“pod 状态”资源可以接受“pod”类型的 PUT，对于哪些字段可以更改具有不同的规则。

Kubernetes 的未来版本可能允许使用 JSON 之外的替代对象编码。

### &#x20;资源动词

API资源应使用传统的REST模式：

* GET / - 检索类型 的列表，例如 GET /pods 返回 Pod 列表。
* POST / - 从客户端提供的 JSON 对象创建新资源。
* GET // - 检索具有给定名称的单个资源，例如 GET /pods/first 返回名为“first”的 Pod。时间应该是恒定的，并且资源的大小应该受到限制。
* DELETE // - 删除具有给定名称的单个资源。 DeleteOptions 可以指定 GracePeriodSeconds，即应删除对象之前的可选持续时间（以秒为单位）。各个种类可以声明提供默认宽限期的字段，并且不同种类可以具有不同种类范围的默认宽限期。用户提供的宽限期会覆盖默认宽限期，包括零宽限期（“现在”）。
* DELETE / - 删除 类型的列表，例如 DELETE /pods Pod 列表。
* PUT // - 使用客户端提供的 JSON 对象更新或创建具有给定名称的资源。是否可以使用 PUT 请求创建资源取决于特定资源的存储策略配置，特别是`AllowCreateOnUpdate()`返回值。大多数内置类型不允许这样做。
* PATCH // - 有选择地修改资源的指定字段。请参阅[下面的](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#patch-operations)更多信息。
* GET /?watch=true - 接收与随时间推移对给定类型的任何资源所做的更改相对应的 JSON 对象流。

#### &#x20;补丁操作

API 支持三种不同的 PATCH 操作，由相应的 Content-Type 标头决定：

* &#x20;JSON 补丁， `Content-Type: application/json-patch+json`
  * 根据[RFC6902](https://tools.ietf.org/html/rfc6902)中的定义，JSON 补丁是在资源上执行的一系列操作，例如 `{"op": "add", "path": "/a/b/c", "value": [ "foo", "bar" ]}` 。有关如何使用 JSON Patch 的更多详细信息，请参阅 RFC。
* &#x20;合并补丁， `Content-Type: application/merge-patch+json`
  * 正如[RFC7386](https://tools.ietf.org/html/rfc7386)中所定义的，合并补丁本质上是资源的部分表示。提交的 JSON 与当前资源“合并”以创建新资源，然后保存新资源。有关如何使用 Merge Patch 的更多详细信息，请参阅 RFC。
* 战略合并补丁， `Content-Type: application/strategic-merge-patch+json`
  * 战略合并补丁是合并补丁的自定义实现。有关其工作原理以及为何需要引入它的详细说明，请参阅[此处](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/strategic-merge-patch.md)。

### 简称和类别

资源实现者可以选择在为资源类型发布的发现信息中包含“短名称”和类别，客户端可以在解决不明确的用户调用时将其用作提示。

对于编译入的资源，这些由 REST 处理程序`ShortNames() []string`和`Categories() []string`实现控制。

对于自定义资源，这些资源由 CustomResourceDefinition 中的`.spec.names.shortNames`和`.spec.names.categories`字段控制。

#### &#x20;简称

注意：由于短名称冲突（相互冲突或与资源类型冲突）时会发生不可预测的行为，因此请勿向内置资源添加新的短名称，除非 API 审阅者特别允许。请参阅问题[#117742](https://issue.k8s.io/117742#issuecomment-1545945336)和[#108573](http://issue.k8s.io/108573) 。

客户端可以使用发现中列出的“短名称”作为提示来解决对单个资源的不明确的用户调用。

内置短名称的示例包括：

* `ds` -> `apps/v* daemonsets`
* `sts` -> `apps/v* statefulsets`
* `hpa` -> `autoscaling/v* horizontalpodautoscalers`

例如，仅提供内置 API 类型， `kubectl get sts`相当于 `kubectl get statefulsets.v1.apps` 。

短名称匹配的优先级可能低于资源类型的精确匹配，因此，如果这些自定义资源类型与短名称重叠，则使用短名称会增加安装了自定义资源的集群中出现不一致行为的可能性。

继续上面的示例，如果在集群中安装了`.spec.names.plural`设置为`sts`的自定义资源， `kubectl get sts`将切换为检索自定义资源的实例。

#### &#x20;类别

注意：由于类别与资源类型冲突时行为不一致，并且很难知道何时可以安全地将新资源添加到现有类别，因此除非 API 审核者特别允许，否则请勿向内置资源添加新类别。请参阅问题[#7547](https://github.com/kubernetes/kubernetes/issues/7547#issuecomment-355835279) [#42885](https://github.com/kubernetes/kubernetes/issues/42885#issuecomment-531265679)以及[添加到“全部”类别的注意事项，](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-cli/kubectl-conventions.md#rules-for-extending-special-resource-alias---all)以获取遇到的困难的示例。

客户端可以使用发现中列出的类别作为解决用户对多个资源的调用的提示。

内置类别及其映射的资源示例包括：

* `api-extensions`
  * `apiregistration.k8s.io/v* apiservices`
  * `admissionregistration.k8s.io/v* mutatingwebhookconfigurations`
  * `admissionregistration.k8s.io/v* validatingwebhookconfigurations`
  * `admissionregistration.k8s.io/v* validatingadmissionpolicies`
  * `admissionregistration.k8s.io/v* validatingadmissionpolicybindings`
  * `apiextensions.k8s.io/v* customresourcedefinitions`
* `all`
  * `v1 pods`
  * `v1 replicationcontrollers`
  * `v1 services`
  * `apps/v* daemonsets`
  * `apps/v* deployments`
  * `apps/v* replicasets`
  * `apps/v* statefulsets`
  * `autoscaling/v* horizontalpodautoscalers`
  * `batch/v* cronjobs`
  * `batch/v* jobs`

对于上述类别，并且仅提供内置 API 类型， `kubectl get all`相当于 `kubectl get pods.v1.,replicationcontrollers.v1.,services.v1.,daemonsets.v1.apps,deployments.v1.apps,replicasets.v1.apps,statefulsets.v1.apps,horizontalpodautoscalers.v2.autoscaling,cronjobs.v1.batch,jobs.v1.batch,` 。

### &#x20;幂等性

所有兼容的 Kubernetes API 必须支持“名称幂等性”，并在请求 POST 与系统中现有对象同名的对象时以 HTTP 状态代码 409 进行响应。有关详细信息，请参阅[标识符文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/)。

可以使用`metadata.generateName`请求系统生成的名称。 GenerateName 指示服务器在保留该名称之前应使其唯一。该字段的非空值指示服务器应尝试使名称唯一（并且返回给客户端的名称将与传递的名称不同）。如果未提供名称字段，则该字段的值将与服务器上的随机后缀组合。提供的值必须在名称规则内有效，并且可能会被后缀的长度截断。如果指定了此字段，并且 Name 不存在，则如果生成的名称存在，服务器将返回 409，并带有 Reason `AlreadyExists` ，并且客户端应重试（在等待至少 Retry-After 标头中指示的时间后，如果它存在）。

### &#x20;可选与必需

字段必须是可选的或必填的。

可选字段具有以下属性：

* 他们在 Go 中有`+optional`注释标签。
* 它们是 Go 定义中的指针类型（例如`AwesomeFlag *SomeFlag` ）或具有内置的`nil`值（例如映射和切片）。
* API 服务器应允许在未设置此字段的情况下 POST 和 PUT 资源。

在大多数情况下，可选字段还应该具有`omitempty`结构标记（ `omitempty`选项指定如果字段具有空值，则应从 json 编码中省略该字段）。但是，如果您希望未提供的可选字段与提供空值的可选字段具有不同的逻辑，请不要使用`omitempty` （例如 [kubernetes/kubernetes#34641](https://github.com/kubernetes/kubernetes/issues/34641) ）。

请注意，为了向后兼容，任何具有`omitempty`结构标记的字段都将被视为可选，但这在将来可能会发生变化，强烈建议使用`+optional`注释标记。

必填字段具有相反的属性，即：

* 他们没有`+optional`评论标签。
* 它们没有`omitempty`结构标记。
* 它们不是 Go 定义中的指针类型（例如`AnotherFlag SomeFlag` ）。
* API 服务器不应允许在未设置此字段的情况下 POST 或 PUT 资源。

使用`+optional`或`omitempty`标签会导致 OpenAPI 文档反映该字段是可选的。

使用指针可以区分该类型的未设置和零值。在某些情况下，原则上可选字段不需要指针，因为零值是被禁止的，因此意味着未设置。代码库中有这样的示例。然而：

* 实现者可能很难预测可能需要将空值与零值区分开的所有情况
* 即使指定了 omitempty，结构也不会从编码器输出中省略，这很混乱；
* 对于 Go 语言客户端以及使用相应类型的任何其他客户端的用户来说，让指针始终意味着可选是更清楚的

因此，我们要求指针始终与没有内置`nil`值的可选字段一起使用。

### &#x20;违约

一般来说，我们希望在 API 中明确表示默认值，而不是断言“未指定的字段获得默认行为”。这很重要，以便：

* 默认值可以在较新的 API 版本中演变和更改
* 存储的配置描述了完整的期望状态，使系统更容易确定如何实现该状态，并让用户知道会发生什么

创建或更新（包括修补和应用）资源时，可以通过 3 种不同的方式应用默认值：

1. 静态：根据请求的 API 版本以及资源中可能的其他字段，可以在 API 调用期间为字段分配值
2. 准入控制：根据配置的准入控制器以及集群内外可能的其他状态，可以在 API 调用期间为字段分配值
3. 控制器：API 调用完成后可以对资源进行任意更改（在允许的范围内）

在决定使用哪种机制和管理语义时需要小心。

#### &#x20;静态默认值

静态默认值特定于每个 API 版本。使用“v1”API 创建对象时应用的默认字段值可能与使用“v2”API 时应用的值不同。在大多数情况下，这些值由 API 版本定义为文字值（例如“如果未指定此字段，则默认为 0”）。

在某些情况下，这些值可能以其他字段为条件或确定性地从其他字段导出（例如，“如果 otherField 是 X，则此字段默认为 0”或“此字段默认为 otherField 的值”）。请注意，此类派生默认值在更新时存在危险 - 如果“其他”字段发生更改，则派生字段也可能必须更改。静态默认逻辑不知道更新，也没有“先前值”的概念，这意味着这种字段间关系成为用户的问题 - 他们必须更新他们关心的字段和“其他”字段。

在极少数情况下，这些值可能从某个池中分配或通过某种其他方法确定（例如，服务的 IP 和 IP 系列相关字段需要考虑其他配置设置）。

当解码版本化数据时，这些值由 API 服务器同步应用。对于 CREATE 和 UPDATE 操作，这是相当简单的 - 当 API 服务器收到（版本控制）请求时，在任何进一步处理之前立即应用默认值。 API 调用完成后，所有静态默认值都将被设置并存储。资源的后续 GET 将显式包含默认值。但是，当从存储中读取对象（即 GET 操作）时，静态默认值也适用。这意味着，当某人获取“较旧”的存储对象时，自存储该对象以来已添加到 API 的任何字段都将被默认并根据存储的 API 版本返回。

静态默认值是逻辑上必需的值的最佳选择，但其值适合大多数用户。静态默认不能考虑除所操作的对象之外的任何状态（服务 API 的复杂性就是一个例子）。

可以使用`+default=`标签在字段上指定默认值。基元将直接分配其值，而结构将经历 JSON 解组过程。如果未分配默认值，则没有`omitempty` json 标记的字段将默认为其相应类型的零值。

有关更多信息，请参阅[默认文档](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#defaulting)。

#### 准入控制默认值

在某些情况下，设置不是从相关对象派生的默认值很有用。例如，在创建 PersistentVolumeClaim 时，必须指定存储类。对于许多用户来说，最好的答案是“无论集群管理员决定默认什么”。 StorageClass 是与 PersistedVolumeClaim 不同的 API，并且哪个表示为默认值可能随时更改。因此，这不符合静态违约的条件。

相反，我们可以提供内置的准入控制器或 MutatingWebhookConfiguration。与静态默认值不同，这些在决定默认值时可能会考虑外部状态（例如 StorageClass 对象上的注释），并且必须处理诸如竞争条件之类的事情（例如，StorageClass 被指定为默认值，但准入控制器尚未看到该更新）。这些准入控制器是严格可选的并且可以禁用。因此，以这种方式初始化的字段必须是严格可选的。

与静态默认值一样，它们与相关 API 操作同步运行，并且当 API 调用完成时，所有静态默认值都将被设置。资源的后续 GET 将显式包含默认值。

#### 控制器分配的默认值（又名后期初始化）

后期初始化是指在创建/更新（异步）对象后由系统控制器设置资源字段。例如，调度程序在创建 pod 后设置`pod.spec.nodeName`字段。称其为“默认”有些夸张，但由于它如此常见且有用，因此将其包含在此处。

与准入控制默认值一样，这些控制器在决定设置哪些值时可能会考虑外部状态，必须处理竞争条件，并且可以被禁用。以这种方式初始化的字段必须是严格可选的（这意味着观察者将看到没有设置这些字段的对象，这是允许的并且在语义上是正确的）。

与所有控制器一样，必须注意不要破坏不相关的字段或值（例如在数组中）。建议使用补丁或应用机制之一来促进控制器的组合和并发。

#### &#x20;什么可能被违约

所有形式的违约只能进行以下类型的修改：

* 设置之前未设置的字段
* &#x20;向地图添加键
* 将值添加到具有可合并语义的数组（ `+listType=map`标签或`patchStrategy:"merge"`属性）

特别是，我们永远不想更改或覆盖用户提供的值。如果他们请求的内容无效，他们应该会收到错误。

&#x20;这些规则确保：

1. 用户（具有足够的权限）可以通过显式设置默认的字段来覆盖任何系统默认行为
2. 用户的更新可以与默认值合并

#### PUT 操作的注意事项

创建对象并应用默认值后，随着时间的推移发生更新是很常见的。 Kubernetes 提供了多种更新对象的方法，这些方法保留了除正在更新的字段之外的字段中的现有值（例如，战略合并补丁和服务器端应用）。然而，有一种不太明显的更新对象的方法，它可能与默认值产生不良交互 - PUT（又名`kubectl replace` ）。

目标是，对于给定的输入（例如 YAML 文件），对现有对象进行 PUT 应该产生与使用该输入创建对象相同的结果。使用相同的输入第二次调用 PUT 应该是幂等的，并且不应更改资源。面对版本偏差，即使是读-修改-写周期也不是完美的解决方案。

当使用 PUT 更新对象时，API 服务器将看到具有先前分配的默认值的“旧”对象和具有新分配的默认值的“新”对象。对于静态默认值，如果 CREATE 和 PUT 使用不同的 API 版本，这可能会出现问题。例如，API 的“v1”可能会将字段默认为`false` ，而“v2”则将其默认为`true` 。如果对象是通过 API v1 (field = `false` ) 创建的，然后通过 API v2 替换的，则该字段将尝试更改为`true` 。当值是从相关对象外部的源（例如服务 IP）分配或派生时，这也可能是一个问题。

对于某些 API，这是可以接受且可行的。对于其他人来说，验证可能会不允许这样做。在后一种情况下，用户将收到有关尝试更改 YAML 中甚至不存在的字段的错误。在添加新字段时，这尤其危险 - 旧客户端甚至可能不知道该字段的存在，甚至导致读取-修改-写入周期失败。虽然它是“正确的”（从某种意义上说，这确实是他们对 PUT 的要求），但它没有帮助，而且是一个糟糕的用户体验。

添加具有静态或准入控制默认值的字段时，必须考虑这一点。如果该字段在创建后不可变，请考虑添加逻辑，以在“未设置”时将“旧”对象的值手动“修补”到“新”对象，而不是返回错误或分配不同的值（例如服务 IP）。这通常是用户的意思，即使这不是他们所说的。这可能需要以不同的方式设置默认值（例如，在理解更新的注册表代码中，而不是在不理解更新的版本化默认代码中）。请小心检测并报告指定“新”值但与“旧”值不同的合法错误。

对于控制器默认字段，情况更加令人不快。在提交 API 操作之前，控制器没有机会“修补”该值。如果允许“未设置”值，则该值将被保存，并且所有监视客户端都会收到通知。如果不允许“未设置”值或不允许进行突变，则用户将收到错误，而我们对此无能为力。

### 并发控制和一致性

Kubernetes 利用\_资源版本\_的概念来实现乐观并发。所有 Kubernetes 资源都有一个“resourceVersion”字段作为其元数据的一部分。此resourceVersion 是一个字符串，用于标识对象的内部版本，客户端可以使用该字符串来确定对象何时发生更改。当记录即将更新时，会根据预先保存的值检查其版本，如果不匹配，则更新会失败并显示 StatusConflict（HTTP 状态代码 409）。

每次修改对象时，服务器都会更改资源版本。如果资源版本包含在 PUT 操作中，系统将通过验证资源版本的当前值是否与指定值匹配来验证在读/修改/写入周期期间没有对资源进行其他成功的更改。

ResourceVersion 当前由[etcd 的 mod\_revision](https://etcd.io/docs/latest/learning/api/#key-value-pair)支持。但是，需要注意的是，应用程序\_不应\_依赖 Kubernetes 维护的版本控制系统的实现细节。我们将来可能会更改resourceVersion的实现，例如将其更改为时间戳或每个对象计数器。

客户端了解 ResourceVersion 预期值的唯一方法是从服务器接收该值以响应先前的操作（通常是 GET）。该值必须被客户端视为不透明，并未经修改地传递回服务器。客户端不应假设资源版本在跨命名空间、不同类型的资源或不同服务器之间具有含义。目前，resourceVersion 的值设置为与 etcd 的排序器匹配。您可以将其视为 API 服务器可用于排序请求的逻辑时钟。但是，我们预计 resourcesVersion 的实现将来会发生变化，例如在我们按种类和/或命名空间或端口到另一个存储系统对状态进行分片的情况下。

如果发生冲突，此时正确的客户端操作是再次获取资源，重新应用更改，然后再次尝试提交。该机制可用于防止如下竞争：

```
Client #1                                  Client #2
GET Foo                                    GET Foo
Set Foo.Bar = "one"                        Set Foo.Baz = "two"
PUT Foo                                    PUT Foo
```

当这些序列并行发生时，对 Foo.Bar 的更改或对 Foo.Baz 的更改可能会丢失。

另一方面，当指定resourceVersion时，其中一个PUT将失败，因为无论哪一个写入成功都会更改Foo的resourceVersion。

ResourceVersion 可以用作将来其他操作（例如，GET、DELETE）的前提条件，例如在存在缓存的情况下实现写后读一致性。

“监视”操作使用查询参数指定资源版本。它用于指定开始监视指定资源的点。这可用于确保资源（或资源列表）的 GET 与后续监视之间不会遗漏任何突变，即使资源的当前版本是更新的。这是当前列表操作（集合上的 GET）返回资源版本的主要原因。

### &#x20;序列化格式

API 可以返回任何资源的替代表示形式以响应 Accept 标头或在替代端点下，但 API 响应的输入和输出的默认序列化必须是 JSON。

内置资源也接受 protobuf 编码。由于原型不是自描述的，因此有一个信封包装器来描述内容的类型。

所有日期都应序列化为 RFC3339 字符串。

### &#x20;单位

单位必须在字段名称中明确显示（例如`timeoutSeconds` ），或者必须指定为值的一部分（例如`resource.Quantity` ）。尽管目前我们使用`fooSeconds`约定来表示持续时间，但首选哪种方法尚待确定。

持续时间字段必须表示为整数字段，单位是字段名称的一部分（例如`leaseDurationSeconds` ）。我们不在 API 中使用 Duration，因为这需要客户端实现与 go 兼容的解析。

### &#x20;选择字段

某些 API 可能需要识别 JSON 对象中的哪个字段无效，或者引用从单独资源中提取的值。当前建议是使用标准 JavaScript 语法来访问该字段，假设 JSON 对象已转换为 JavaScript 对象，不带前导点，例如`metadata.name` 。

&#x20;示例：

* 在数组“fields”中的第二项中找到对象“state”中的字段“current”： `fields[1].state.current`

### &#x20;对象引用

命名空间类型上的对象引用通常应仅引用同一命名空间中的对象。由于命名空间是安全边界，跨命名空间引用可能会产生意想不到的影响，包括：

1. 将一个命名空间的信息泄漏到另一个命名空间中。在原始文件中放置状态消息甚至有关引用对象的内容是很自然的。这是跨命名空间的问题。
2. 对其他命名空间的潜在入侵。通常，引用可以访问一条被引用的信息，因此能够跨命名空间表达“给我那个”是危险的，而无需从两个涉及的命名空间进行权限检查或选择加入的额外工作。
3. 一方无法解决的参照完整性问题。从命名空间/A 引用命名空间/B 并不意味着拥有控制其他命名空间的权力。这意味着您可以引用无法创建或更新的事物。
4. 删除语义不清楚。如果命名空间资源被其他命名空间引用，则删除引用的资源是否会导致删除，或者是否应强制保留引用的资源。
5. 关于创造的语义不清楚。如果引用的资源是在引用后创建的，则无法知道它是否是预期的资源，或者是否是使用相同名称创建的不同资源。

内置类型和ownerReferences不支持跨命名空间引用。如果非内置类型选择跨命名空间引用，则应清楚地描述上述边缘情况的语义，并解决权限问题。这可以通过双重选择加入（推荐人和被推荐人都选择加入）或在入场时执行辅助权限检查来完成。

#### 参考字段的命名

引用字段的名称应采用“{field}Ref”格式，后缀中始终包含“Ref”。

“{field}”组件的命名应表明引用的目的。例如，端点中的“targetRef”表示对象引用指定目标。

可以让“{field}”组件指示资源类型。例如，引用机密时为“secretRef”。然而，如果该字段扩展为引用多个类型，则存在该字段用词不当的风险。

在对象引用列表的情况下，字段应采用“{field}Refs”格式，与上面的单数情况相同。

#### 引用多个版本的资源

大多数资源都有多个版本。例如，核心资源在从 alpha 过渡到 GA 时将会经历版本更改。

控制器应该假设资源的版本可能会更改，并包括适当的错误处理。

#### 处理不存在的资源

在多种情况下，所需的资源可能不存在。示例包括：

* 所需版本的资源不存在。
* 集群引导中的竞争条件导致资源尚未添加。
* &#x20;用户错误。

控制器的编写应假设所引用的资源可能不存在，并包括错误处理以使用户清楚地了解问题。

#### &#x20;字段验证

对象引用中使用的许多值都用作 API 路径的一部分。例如，在路径中使用对象名称来标识该对象。如果未经清理，这些值可用于尝试检索其他资源，例如通过使用具有语义含义的值，例如`..`或`/` 。

让控制器在将字段用作 API 请求中的路径段之前对其进行验证，并发出一个事件来告诉用户验证失败。

有关合法对象名称的更多信息，请参阅[对象名称和 ID](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/) 。

#### 不要修改引用的对象

为了最大限度地减少潜在的权限提升向量，请不要修改正在引用的对象，或者限制对同一命名空间中的对象的修改并限制允许的修改类型（例如，HorizontalPodAutoscaler 控制器仅写入`/scale`子资源）。

#### 最小化复制或打印引用对象的值

由于控制器的权限可能与控制器正在管理的对象的作者的权限不同，因此对象的作者可能没有查看所引用对象的权限。因此，将有关被引用对象的任何值复制到引用对象可以被视为权限升级，从而使用户能够读取他们以前无法访问的值。

相同的场景适用于将有关所引用对象的信息写入事件。

一般来说，不要将从引用对象检索到的信息写入或打印到规范、其他对象或日志中。

必要时，请考虑这些值是否是引用对象的作者可以通过其他方式访问的值（例如，已需要正确填充对象引用）。

#### 对象引用示例

以下部分说明了各种对象引用场景的推荐架构。

下面概述的模式旨在随着可引用对象类型的扩展启用纯附加字段，因此向后兼容。

例如，可以从单一资源类型转变为多种资源类型，而无需对架构进行重大更改。

**单一资源参考**

单一类型的对象引用很简单，因为控制器可以对识别对象所需的大多数限定符进行硬编码。例如，需要提供的唯一值是名称（和命名空间，尽管不鼓励跨命名空间引用）：

```yaml
# for a single resource, the suffix should be Ref, with the field name
# providing an indication as to the resource type referenced.
secretRef:
    name: foo
    # namespace would generally not be needed and is discouraged,
    # as explained above.
    namespace: foo-namespace
```

仅当目的是始终仅引用单个资源时才应使用此模式。如果可以扩展到多种资源类型，请使用[多资源引用](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#multiple-resource-reference)。

&#x20;**控制器行为**

操作员需要知道需要从中检索值的对象的版本、组和资源名称，并且可以使用发现客户端或直接构建 API 路径。

**多种资源参考**

当引用可以指向一组有界的有效资源类型时，将使用多类对象引用。

与单一类型对象引用一样，操作员可以提供缺失的字段，前提是存在的字段足以在支持的类型集中唯一标识对象资源类型。

```yaml
# guidance for the field name is the same as a single resource.
fooRef:
    group: sns.services.k8s.aws
    resource: topics
    name: foo
    namespace: foo-namespace
```

尽管并不总是需要帮助控制器识别资源类型，但包含“组”以避免资源存在于多个组中时出现歧义。它还为最终用户提供了清晰度，并允许复制粘贴引用，而不会因处理引用的不同控制器而改变引用类型。

&#x20;**种类与资源**

对象引用中一个常见的混淆点是是否使用“种类”或“资源”字段构造引用。从历史上看，Kubernetes 中的大多数对象引用都使用“kind”。这并不像“资源”那么精确。尽管“组”和“资源”的每个组合在 Kubernetes 中都必须是唯一的，但“组”和“种类”并不总是如此。多个资源可以使用相同的“种类”。

通常，Kubernetes 中的所有对象都有一个规范的主要资源 - 例如“pod”，代表创建和删除“Pod”模式资源的方式。虽然资源架构可能无法直接创建，例如仅在多个工作负载的“scale”子资源中使用的“Scale”对象，但大多数对象引用通过其架构来寻址主要资源。在对象引用的上下文中，“种类”指的是模式，而不是资源。

如果对象引用的实现始终具有将种类映射到资源的明确方法，则在对象引用中使用“kind”是可以接受的。一般来说，这要求实现在种类和资源之间具有预定义的映射（对于使用“种类”的内置引用就是这种情况）。依靠动态类型来进行资源映射是不安全的。即使“种类”最初仅动态映射到单个资源，也可能会安装引用相同“种类”的另一个资源，从而可能破坏任何动态资源映射。

如果对象引用可用于引用任意类型的资源，并且种类和资源之间的映射可能不明确，则应在对象引用中使用“资源”。

Ingress API 提供了一个很好的示例，说明“kind”在哪里可以接受对象引用。 API 支持后端引用作为扩展点。实现可以使用它来支持将流量转发到自定义目标，例如存储桶。重要的是，支持的目标类型由 API 的每个实现明确定义，并且类型映射到哪个资源没有歧义。这是因为每个 Ingress 实现都有一个类型到资源的硬编码映射。

如果使用“kind”而不是“resource”，上面的对象引用将如下所示：

```yaml
fooRef:
    group: sns.services.k8s.aws
    kind: Topic
    name: foo
    namespace: foo-namespace
```

&#x20;**控制器行为**

操作员可以存储（组，资源）到其所需资源版本的映射。从那里，它可以构造资源的完整路径，并检索对象。

也可以让控制器选择通过发现客户端找到的版本。但是，由于模式可能因资源的不同版本而异，因此控制器还必须处理这些差异。

&#x20;**通用对象引用**

当需要提供指向某个对象的指针以简化用户的发现时，可以使用通用对象引用。例如，这可用于引用发生的`core.v1.Event`的目标对象。

对于通用对象引用，除了标准信息（例如ObjectMeta）之外，不可能提取有关引用对象的任何信息。由于任何标准字段都存在于资源的任何版本中，因此在这种情况下可以不包含版本：

```yaml
fooObjectRef:
    group: operator.openshift.io
    resource: openshiftapiservers
    name: cluster
    # namespace is unset if the resource is cluster-scoped, or lives in the
    # same namespace as the referrer.
```

&#x20;**控制器行为**

操作员应该通过发现客户端找到资源（因为未提供版本）。由于任何可检索字段对于所有对象都是通用的，因此任何版本的资源都应该这样做。

&#x20;**现场参考**

当需要从引用对象的特定字段中提取值时，将使用字段引用。

字段引用与其他引用类型不同，因为操作员在引用之前不了解对象。由于资源的不同版本的对象模式可能有所不同，这意味着此类引用需要“版本”。

```yaml
fooFieldRef:
   version: v1 # version of the resource
   # group is elided in the ConfigMap example, since it has a blank group in the OpenAPI spec.
   resource: configmaps
   fieldPath: data.foo
```

fieldPath 应指向单个值，并使用[推荐的字段选择器表示法](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#selecting-fields)来表示字段路径。

&#x20;**控制器行为**

在这种情况下，用户将提供所有必需的路径元素：组、版本、资源、名称和可能的命名空间。因此，控制器可以构造 API 前缀并对其进行查询，而无需使用发现客户端：

```
/apis/{group}/{version}/{resource}/
```

### &#x20;HTTP 状态代码

服务器将使用与 HTTP 规范匹配的 HTTP 状态代码进行响应。有关服务器将发送的状态代码类型的详细信息，请参阅下面的部分。

API 可能会返回以下 HTTP 状态代码。

&#x20;**成功代码**

* `200 StatusOK`
  * 表明请求成功完成。
* `201 StatusCreated`
  * 指示创建种类的请求已成功完成。
* `204 StatusNoContent`
  * 表示请求已成功完成，并且响应不包含正文。
  * 响应 HTTP OPTIONS 请求而返回。

&#x20;**错误代码**

* `307 StatusTemporaryRedirect`
  * 表示所请求资源的地址已更改。
  * 建议的客户端恢复行为：
    * &#x20;按照重定向进行操作。
* `400 StatusBadRequest`
  * 表示请求无效。
  * 建议的客户端恢复行为：
    * 不要重试。修复请求。
* `401 StatusUnauthorized`
  * 表示可以到达服务器并理解该请求，但拒绝采取任何进一步的操作，因为客户端必须提供授权。如果客户端已提供授权，则服务器指示提供的授权不合适或无效。
  * 建议的客户端恢复行为：
    * 如果用户未提供授权信息，则提示他们输入适当的凭据。如果用户提供了授权信息，请通知他们他们的凭据被拒绝，并可以选择再次提示他们。
* `403 StatusForbidden`
  * 表示可以到达服务器并理解该请求，但拒绝采取任何进一步的操作，因为它被配置为出于某种原因拒绝客户端对所请求资源的访问。
  * 建议的客户端恢复行为：
    * 不要重试。修复请求。
* `404 StatusNotFound`
  * 表示请求的资源不存在。
  * 建议的客户端恢复行为：
    * 不要重试。修复请求。
* `405 StatusMethodNotAllowed`
  * 指示代码不支持客户端尝试对资源执行的操作。
  * 建议的客户端恢复行为：
    * 不要重试。修复请求。
* `409 StatusConflict`
  * 表示客户端尝试创建的资源已存在，或者请求的更新操作由于冲突而无法完成。
  * 建议的客户端恢复行为：
    * 如果创建新资源：
      * 更改标识符并重试，或者 GET 并比较预先存在的对象中的字段并发出 PUT/更新以修改现有对象。
    * 如果更新现有资源：
      * 请参阅下面的`status`响应中的`Conflict`部分，了解如何检索有关冲突性质的更多信息。
      * 获取并比较预先存在的对象中的字段，合并更改（如果根据先决条件仍然有效），然后重试更新的请求（包括`ResourceVersion` ）。
* `410 StatusGone`
  * 表示该项目在服务器上不再可用并且没有已知的转发地址。
  * 建议的客户端恢复行为：
    * 不要重试。修复请求。
* `422 StatusUnprocessableEntity`
  * 表示由于请求中提供的数据无效，无法完成请求的创建或更新操作。
  * 建议的客户端恢复行为：
    * 不要重试。修复请求。
* `429 StatusTooManyRequests`
  * 指示已超出客户端速率限制或服务器收到的请求数量超出其处理能力。
  * 建议的客户端恢复行为：
    * 从响应中读取`Retry-After` HTTP 标头，并在重试之前至少等待那么长时间。
* `500 StatusInternalServerError`
  * 表示可以到达服务器并理解该请求，但是发生意外的内部错误并且调用结果未知，或者服务器无法在合理的时间内完成操作（这可能是由于临时服务器负载或与另一台服务器的瞬时通信问题）。
  * 建议的客户端恢复行为：
    * 使用指数退避重试。
* `503 StatusServiceUnavailable`
  * 表示所需的服务不可用。
  * 建议的客户端恢复行为：
    * 使用指数退避重试。
* `504 StatusServerTimeout`
  * 表示请求无法在给定时间内完成。仅当客户端在请求中指定超时参数时才能获得此响应。
  * 建议的客户端恢复行为：
    * 增加超时参数的值并使用指数退避重试。

### &#x20;响应状态类型

当发生错误时，Kubernetes 将始终从任何 API 端点返回`Status`类型。客户端应该在适当的时候处理这些类型的对象。

在两种情况下，API 将返回`Status`类型：

* 当操作不成功时（即服务器返回非 2xx HTTP 状态代码时）。
* 当 HTTP `DELETE`调用成功时。

状态对象被编码为 JSON 并作为响应的正文提供。状态对象包含供 API 的人类和机器使用者获取有关故障原因的更详细信息的字段。状态对象中的信息补充但不会覆盖 HTTP 状态代码的含义。当状态对象中的字段与通常定义的 HTTP 标头具有相同含义并且该标头随响应返回时，应将标头视为具有更高的优先级。

&#x20;**例子：**

```shell
$ curl -v -k -H "Authorization: Bearer WhCDvq4VPpYhrcfmF6ei7V9qlbqTubUc" https://10.240.122.184:443/api/v1/namespaces/default/pods/grafana

> GET /api/v1/namespaces/default/pods/grafana HTTP/1.1
> User-Agent: curl/7.26.0
> Host: 10.240.122.184
> Accept: */*
> Authorization: Bearer WhCDvq4VPpYhrcfmF6ei7V9qlbqTubUc
>

< HTTP/1.1 404 Not Found
< Content-Type: application/json
< Date: Wed, 20 May 2015 18:10:42 GMT
< Content-Length: 232
<
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {},
  "status": "Failure",
  "message": "pods \"grafana\" not found",
  "reason": "NotFound",
  "details": {
    "name": "grafana",
    "kind": "pods"
  },
  "code": 404
}
```

`status`字段包含两个可能值之一：

* `Success`
* `Failure`

`message`可能包含人类可读的错误描述

`reason`可能包含机器可读的单字驼峰命名法描述，说明为什么此操作处于`Failure`状态。如果该值为空，则没有可用信息。 `reason`阐明了 HTTP 状态代码，但不会覆盖它。

`details`可能包含与原因相关的扩展数据。每个原因都可以定义其自己的扩展细节。该字段是可选的，并且不保证返回的数据符合除原因类型定义之外的任何模式。

`reason`和`details`字段的可能值：

* `BadRequest`
  * 表示请求本身无效，因为该请求没有任何意义，例如删除只读对象。
  * 这与上面的`Invalid` `status reason`不同，后者表示 API 调用可能成功，但数据无效。
  * 返回 BadRequest 的 API 调用永远不会成功。
  * HTTP 状态代码： `400 StatusBadRequest`
* `Unauthorized`
  * 表示可以到达服务器并理解该请求，但在没有客户端提供适当授权的情况下拒绝采取任何进一步的操作。如果客户端已提供授权，则此错误表示提供的凭据不足或无效。
  * &#x20;详细信息（可选）：
    * `kind string`
      * 未授权资源的种类属性（在某些操作上可能与请求的资源不同）。
    * `name string`
      * 未授权资源的标识符。
  * HTTP 状态代码： `401 StatusUnauthorized`
* `Forbidden`
  * 表示可以到达服务器并理解该请求，但拒绝采取任何进一步的操作，因为它被配置为出于某种原因拒绝客户端对所请求资源的访问。
  * &#x20;详细信息（可选）：
    * `kind string`
      * 禁止资源的种类属性（在某些操作上可能与请求的资源不同）。
    * `name string`
      * 禁止资源的标识符。
  * HTTP 状态代码： `403 StatusForbidden`
* `NotFound`
  * 指示无法找到此操作所需的一个或多个资源。
  * &#x20;详细信息（可选）：
    * `kind string`
      * 缺失资源的种类属性（在某些操作上可能与请求的资源不同）。
    * `name string`
      * 丢失资源的标识符。
  * HTTP 状态代码： `404 StatusNotFound`
* `AlreadyExists`
  * 表明您正在创建的资源已经存在。
  * &#x20;详细信息（可选）：
    * `kind string`
      * 冲突资源的种类属性。
    * `name string`
      * 冲突资源的标识符。
  * HTTP 状态代码： `409 StatusConflict`
* `Conflict`
  * 表示由于冲突而无法完成请求的更新操作。客户可能需要更改请求。每个资源可以定义指示冲突性质的自定义详细信息。
  * HTTP 状态代码： `409 StatusConflict`
* `Invalid`
  * 表示由于请求中提供的数据无效，无法完成请求的创建或更新操作。
  * &#x20;详细信息（可选）：
    * `kind string`
      * 无效资源的 kind 属性
    * `name string`
      * 无效资源的标识符
    * `causes`
      * 一个或多个`StatusCause`条目指示所提供资源中的数据无效。将设置`reason` 、 `message`和`field`属性。
  * HTTP 状态代码： `422 StatusUnprocessableEntity`
* `Timeout`
  * 表示请求无法在给定时间内完成。如果服务器决定对客户端进行速率限制，或者服务器过载并且此时无法处理请求，则客户端可能会收到此响应。
  * HTTP 状态代码： `429 TooManyRequests`
  * 服务器应设置`Retry-After` HTTP 标头并在对象的详细信息字段中返回`retryAfterSeconds` 。值`0`是默认值。
* `ServerTimeout`
  * 表示可以到达服务器并理解该请求，但是 无法在合理的时间内完成该操作。这可能是由于暂时的 服务器负载或与另一台服务器的瞬时通信问题。
    * &#x20;详细信息（可选）：
      * `kind string`
        * 所操作的资源的种类属性。
      * `name string`
        * 正在尝试的操作。
  * 服务器应设置`Retry-After` HTTP 标头并在对象的详细信息字段中返回`retryAfterSeconds` 。值`0`是默认值。
  * HTTP 状态代码： `504 StatusServerTimeout`
* `MethodNotAllowed`
  * 指示代码不支持客户端尝试对资源执行的操作。
  * 例如，尝试删除只能创建的资源。
  * 返回 MethodNotAllowed 的 API 调用永远不会成功。
  * HTTP 状态代码： `405 StatusMethodNotAllowed`
* `InternalError`
  * 表示发生了内部错误，这是意外的并且调用的结果未知。
  * &#x20;详细信息（可选）：
    * `causes`
      * &#x20;原来的错误。
  * HTTP 状态代码： `500 StatusInternalServerError` `code`可能包含此状态的建议 HTTP 返回代码。

### &#x20;活动

事件是状态信息的补充，因为除了当前或以前的状态之外，它们还可以提供一些有关状态和事件的历史信息。为应提醒用户或管理员的情况生成事件。

为每个事件类别选择一个独特、具体、简短的 CamelCase 原因。例如， `FreeDiskSpaceInvalid`是一个很好的事件原因，因为它可能仅指一种情况，但`Started`不是一个很好的原因，因为即使与其他事件字段结合使用，它也不能充分指示开始的内容。

`Error creating foo`或`Error creating foo %s`将适合事件消息，后者更可取，因为它提供更多信息。

累积客户端中的重复事件，尤其是频繁事件，以减少数据量、系统负载以及向用户暴露的噪音。

### &#x20;命名约定

* Go 字段名称必须采用 PascalCase。 JSON 字段名称必须采用驼峰命名法。除了首字母大写之外，两者几乎应该总是匹配。两者中都没有下划线或破折号。
* 字段和资源名称应该是声明性的，而不是命令性的（SomethingDoer、DoneBy、DoneAt）。
* 使用`Node` where 引用集群上下文中的节点资源。在引用单个物理/虚拟系统的属性时使用`Host` ，例如`hostname` 、 `hostPath` 、 `hostNetwork`等。
* `FooController`是一种已弃用的命名约定。以被控制的事物命名（例如， `Job`而不是`JobController` ）。
* 指定`something`发生的时间的字段名称应称为`somethingTime` 。不要使用`stamp` （例如， `creationTimestamp` ）。
* 我们对持续时间使用`fooSeconds`约定，如[单位小节](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#units)中所讨论的。
  * `fooPeriodSeconds`优先用于周期性间隔和其他等待周期（例如，超过`fooIntervalSeconds` ）。
  * `fooTimeoutSeconds`是不活动/无响应期限的首选。
  * `fooDeadlineSeconds`是活动完成期限的首选。
* 不要在 API 中使用缩写，除非它们非常常用，例如“id”、“args”或“stdin”。
* 同样，只有在极其众所周知的情况下才应使用首字母缩略词。首字母缩略词中的所有字母都应具有相同的大小写，并根据具体情况使用适当的大小写。例如，在字段名称的开头，缩写词应全部小写，例如“httpGet”。用作常量时，所有字母都应为大写，例如“TCP”或“UDP”。
* 通过名称引用另一个`Foo`类型资源的字段名称应称为`fooName` 。通过 ObjectReference （或其子集）引用`Foo`类型的另一个资源的字段名称应称为`fooRef` 。
* 更一般地说，如果单位和/或类型可能不明确并且未由值或值类型指定，则在字段名称中包含单位和/或类型。
* 表示名为 'fooable' 的布尔属性的字段名称应称为`Fooable` ，而不是`IsFooable` 。

#### &#x20;命名空间名称

* 命名空间的名称必须是[DNS\_LABEL](https://git.k8s.io/design-proposals-archive/architecture/identifiers.md) 。
* `kube-`前缀是为 Kubernetes 系统命名空间保留的，例如`kube-system`和`kube-public` 。
* 有关更多信息，请参阅[命名空间文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/)。

### 标签、选择器和注释约定

标签是用户的领域。它们旨在使用对用户有意义的属性（而不是对系统有意义）来促进 API 资源的组织和管理。将它们视为用户创建的 mp3 或电子邮件收件箱标签，而不是程序用于存储其数据的目录结构。前者使用户能够应用任意本体，而后者以实现为中心并且不灵活。用户将使用标签来选择要操作的资源、在 CLI/UI 列中显示标签值等。用户应始终对应用于其命名空间中的标签的标签模式保留全部功能和灵活性。

但是，我们应该默认支持常见情况的便利性。例如，我们现在在 ReplicationController 中所做的就是默认情况下自动将 RC 的选择器和标签设置为 pod 模板中的标签（如果尚未设置）。这确保了选择器将与模板匹配，并且可以使用与其创建的 Pod 相同的标签来管理 RC。请注意，一旦我们概括了选择器，就不一定能够明确地生成与任意选择器匹配的标签。

如果用户想要将其他标签应用于未选择的 Pod，例如为了促进 Pod 的采用或期望某些标签值会发生变化，他们可以将选择器设置为 Pod 标签的子集。类似地，RC 的标签可以初始化为 Pod 模板标签的子集，或者可以包括附加/不同的标签。

对于在自己的命名空间内管理资源的严格用户来说，一致地应用确保唯一性的模式并不难。只需确保某个共同标签键的至少一个值与所有其他可比资源不同。我们可以/应该提供一个验证工具来检查这一点。然而，与[标签](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/)中的示例类似的约定的开发使唯一性变得简单。此外，使用相对狭窄的命名空间（例如，每个环境、每个应用程序）可以用于减少可能潜在地导致重叠的资源集。

在用户可能运行杂项的情况下。对于架构不一致的示例，或者工具或组件需要以编程方式生成要选择的新对象的示例，需要有一种简单的方法来生成唯一的标签集。确保集合唯一性的一种简单方法是确保单个标签值的唯一性，例如通过使用资源名称、uid、资源哈希或生成编号。

然而，uid 和哈希值的问题包括它们对用户来说没有语义意义、不易记忆、不易识别、并且不可预测。缺乏可预测性会阻碍使用案例，例如从 pod 创建复制控制器，就像人们在探索系统时想要做的那样，引导自托管集群，或者删除并重新创建采用 pod 的新 RC前一个，例如重命名它。假设存在逻辑顺序，世代数更可预测且更清晰。幸运的是，对于部署来说就是这样。对于作业，创建时间戳的使用在内部很常见。用户应该始终能够关闭自动生成，以便允许上述某些场景。请注意，自动生成的标签也将成为在命名空间、新命名空间、新集群等克隆资源时需要删除的又一个字段，并且在更新标签时需要忽略。通过补丁或读取-修改-写入序列来获取资源。

在标签键中包含系统前缀对用户体验相当不利。只有在用户无法选择标签键的情况下才需要前缀，以避免与用户定义的标签发生冲突。但是，我坚信应该始终允许用户选择要在其资源上使用的标签键，因此应该始终可以覆盖默认标签键。

因此，支持自动生成唯一标签的资源应该有一个`uniqueLabelKey`字段，以便用户可以根据需要指定key，但如果不指定，可以默认设置，例如资源类型，如job，部署或复制控制器。该值至少需要在空间上是唯一的，对于工作来说，也许在时间上是唯一的。

注释的预期用途与标签有很大不同。它们主要由工具和系统扩展生成和使用，或者由最终用户用来参与组件的非标准行为。例如，注释可用于指示资源实例需要非 kubernetes 控制器进行额外处理。注释可以携带任意负载，包括 JSON 文档。与标签一样，注释键可以使用管理域作为前缀（例如`example.com/key-name` ）。无前缀的密钥（例如`key-name` ）是为最终用户保留的。第三方组件必须使用前缀键。 “kubernetes.io”和“k8s.io”域下的关键前缀保留供 kubernetes 项目使用，不得供第三方使用。

在 Kubernetes 的早期版本中，一些正在开发的功能将新的 API 字段表示为注释，通常采用以下形式 `something.alpha.kubernetes.io/name` 或者 `something.beta.kubernetes.io/name` （取决于我们对此的信心）。此模式已被弃用。一些这样的注释可能仍然存在，但不能定义新的注释。新的 API 字段现已作为常规字段开发。

关于 Kubernetes 组件和工具使用标签、注释、污点和其他通用映射键的其他建议：

* 键名应全部小写，单词之间用破折号分隔，而不是驼峰式
  * 例如，优先选择`foo.kubernetes.io/foo-bar`而不是`foo.kubernetes.io/fooBar` ，优先选择`desired-replicas`而不是`DesiredReplicas`
* 无前缀密钥是为最终用户保留的。所有其他标签和注释都必须带有前缀。
* “kubernetes.io”和“k8s.io”下的关键前缀是为 Kubernetes 保留的 项目。
  * 此类密钥实际上是 kubernetes API 的一部分，可能会受到弃用和兼容性政策的约束。
  * “kubernetes.io”是标签和注释的首选形式，“k8s.io”不应用于新的映射键。
* 键名（包括前缀）应该足够精确，以便用户可以合理地理解它的来源和用途。
* 键前缀应包含尽可能多的上下文。
  * 例如，更喜欢 `subsystem.kubernetes.io/parameter` 超过 `kubernetes.io/subsystem-parameter`
* 使用注释来存储负责资源的控制器不需要了解的 API 扩展、不打算作为通用 API 字段的实验字段等。请注意，注释不会由 API 转换机制自动处理。

### &#x20;WebSocket 和 SPDY

Kubernetes 公开的一些 API 操作涉及在客户端和容器之间传输二进制流，包括 Attach、exec、portforward 和日志记录。因此，API 通过 WebSocket 和 SPDY 协议公开可升级 HTTP 连接（[在 RFC 2817 中描述](https://tools.ietf.org/html/rfc2817)）的某些操作。这些操作以其关联的动词（exec、log、attach 和 portforward）作为子资源公开，并通过 GET（以支持浏览器中的 JavaScript）和 POST（语义上准确）请求。

目前使用的主要协议有两种：

1.  &#x20;流媒体频道

    当处理多个独立的二进制数据流时，例如远程执行 shell 命令（写入 STDIN、从 STDOUT 和 STDERR 读取）或转发多个端口，这些流可以多路复用到单个 TCP 连接上。 Kubernetes 支持基于 SPDY 的成帧协议，该协议利用 SPDY 通道；以及 WebSocket 成帧协议，该协议通过在每个二进制块前添加一个指示其通道的字节作为前缀，将多个通道复用到同一个流上。 WebSocket 协议支持可选的子协议，该子协议处理来自客户端的 Base64 编码字节，并从服务器返回 Base64 编码字节和基于字符的通道前缀（“0”、“1”、“2”），以便于在 JavaScript 中使用一个浏览器。
2.  &#x20;流式响应

    流数据通道的默认日志输出是 HTTP 分块传输编码，它可以从服务器返回任意二进制数据流。基于浏览器的 JavaScript 在从分块响应访问原始数据的能力方面受到限制，特别是当返回大量日志时，并且在将来的 API 调用中可能需要传输大文件。流 API 端点支持可选的 WebSocket 升级，该升级提供从服务器到客户端的单向通道，并将数据块作为二进制 WebSocket 帧。公开了一个可选的 WebSocket 子协议，该子协议在将流返回给客户端之前对流进行 base64 编码。

如果客户端有本机支持，则客户端应使用 SPDY 协议，或使用 WebSockets 作为后备。请注意，WebSockets 容易受到队头阻塞的影响，因此客户端必须按顺序读取和处理每条消息。将来，将公开弃用 SPDY 的 HTTP/2 实现。

### &#x20;验证

API 对象在 api 服务器收到后进行验证。验证错误被标记并以`Failure`状态返回给调用者， `reason`设置为`Invalid` 。为了促进一致的错误消息，我们要求验证逻辑尽可能遵守以下准则（尽管会存在例外情况）。

* 尽可能精确。
* 告诉用户他们可以做什么比告诉他们不能做什么更有用。
* 当肯定要求时，使用“必须”。示例：“必须大于 0”、“必须匹配正则表达式 '\[az]+'”。像“应该”这样的词意味着断言是可选的，必须避免。
* 当以否定方式断言格式要求时，请使用“不得”。示例：“不得包含 '..'”。像“不应该”这样的词意味着该断言是可选的，并且必须避免。
* 当以否定的方式断言行为要求时，请使用“可能不会”。示例：“当 otherField 为空时可以不指定”、“只能指定`name` ”。
* 引用文字字符串值时，请用单引号指明文字。示例：“不得包含 '..'”。
* 引用其他字段名称时，请用反引号指明该名称。示例：“必须大于‘request’”。
* 指定不等式时，请使用文字而不是符号。示例：“必须小于 256”、“必须大于或等于 0”。请勿使用“大于”、“大于”、“超过”、“高于”等词语。
* 指定数值范围时，请尽可能使用包含范围。

### 自动资源分配和释放

API 对象通常是包含以下内容的[联合](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#Unions)对象：

1. 一个或多个字段标识特定于 API 对象的`Type` （也称为`discriminator` ）。
2. 一组 N 个字段，在任何给定时间只应设置其中一个字段 - 实际上是一个并集。

在 API 类型上操作的控制器通常根据`Type`和/或用户提供的一些附加数据来分配资源。一个典型的例子是`Service` API 对象，其中 IP 和网络端口等资源将根据`Type`在 API 对象中设置。当用户没有指定资源时，它们将被分配，而当用户指定确切值时，它们将被保留或拒绝。

当用户选择更改`discriminator`值（例如，从`Type X`到`Type Y` ）而不更改任何其他字段时，系统应清除联合体中用于表示`Type X`字段，并释放附加到`Type X`资源`Type X`无论这些值和资源如何分配（即，由用户保留或由系统自动分配），这都应该自动发生。具体的例子是`Service` API。系统分配`NodePorts`和`ClusterIPs`等资源，并自动填充当服务类型为`NodePort`或`ClusterIP` （ `discriminator`值）时，表示它们的字段将在用户将服务类型更改为`ExternalName`时自动清除，此时这些资源和字段值不再适用。

### 代表分配值

许多 API 类型包括代表用户从某个较大空间分配的值（例如某个范围内的 IP 地址或存储桶名称）。这些分配通常由控制器与用户的 API 操作异步驱动。有时，用户可以请求特定值，并且控制器必须确认或拒绝该请求。 Kubernetes 中有很多这样的例子，并且有一些模式用来表示它。

所有这些的共同主题是系统不应信任具有此类字段的用户，并且必须在使用此类请求之前验证或以其他方式确认这些请求。

&#x20;一些例子：

* 服务`clusterIP` ：用户可以请求`spec`中的特定 IP，或者将被分配一个（在同一`spec`字段中）。如果请求特定的 IP，apiserver 将确认 IP 可用，或者如果失败，将同步拒绝 API 操作（罕见）。消费者从`spec`中读取结果。这是安全的，因为该值要么有效，要么从不存储。
* Service `loadBalancerIP` ：用户可以在`spec`中请求特定的IP，或者将被分配一个在`status`中报告的IP。如果请求特定的 IP，LB 控制器将确保 IP 可用或异步报告失败。消费者从`status`读取结果。这是安全的，因为大多数用户没有写入`status`权限。
* PersistentVolumeClaims：用户可以在`spec`中请求特定的 PersistedVolume，或者将被分配一个（在同一`spec`字段中）。如果请求特定的 PV，卷控制器将确保卷可用或异步报告故障。消费者通过检查 PVC 和 PV 来读取结果。这比其他更复杂，因为`spec`值在确认之前就已存储，这可能（假设，由于额外的检查）导致用户访问其他人的 PV。
* VolumeSnapshots：用户可以请求在`spec`中对特定源进行快照。生成的快照的详细信息反映在`status`中。

&#x20;一个反例：

* 服务`externalIPs` ：用户必须在`spec`中指定一个或多个特定的IP。系统无法轻松验证这些 IP（根据其定义，它们是外部 IP）。消费者从`spec`中读取结果。这是不安全的，并且给不受信任的用户带来了问题。

过去，API 约定规定`status`字段始终来自观察，这使得其中一些情况变得不必要的复杂。约定已更新，以允许`status`保存此类分配的值。但这并不是一种一刀切的解决方案。

#### 何时使用`spec`字段

新的 API 几乎不应该这样做。相反，他们应该使用`status` 。如果我们这样做的话，PersistentVolumes 可能会更简单。

#### 何时使用`status`字段

将这些值存储在`status`中是最简单、最直接的模式。这适用于以下情况：

* 分配的值与对象的其余部分高度耦合（例如 pod 资源分配）
* 分配的值总是或几乎总是需要的（即这种类型的大多数实例都会有一个值）
* 模式和控制器是先验已知的（即它不是扩展）
* 允许控制器写入`status`是“安全的”（即它们通过其他`status`字段引起问题的风险很低）。

此类值的使用者可以查看`status`字段以获取“最终”值或指示无法执行分配的原因的错误或条件。

&#x20;**排序操作**

由于几乎所有事情都与其他几乎所有事情异步发生，因此控制器实现应该注意操作的顺序。例如，控制器是否在启动更改之前或之后更新`status`字段取决于需要向系统观察者做出什么保证。在某些情况下，写入`status`字段表示对`spec`值的确认或接受，并且可以在启动之前写入它。但是，如果客户端在启动之前观察`status`值会出现问题，则控制器必须先启动，然后更新`status` 。在一些罕见的情况下，控制器需要确认，然后启动，然后更新到“最终”值。

控制器必须注意考虑在控制循环中断（例如控制器崩溃和重新启动）的情况下如何处理`status`字段，并且必须采取幂等且一致的操作。当使用通知者提供的缓存时，这一点尤其重要，因为该缓存可能不会随着最近的写入而更新。使用资源版本前提条件来检测“冲突”是这种情况下的常见模式。请参阅[此问题](http://issue.k8s.io/105199)的示例。

#### 何时使用不同类型

以不同类型存储分配的值更复杂，但也更灵活。在以下情况下这是最合适的：

* 分配的值是可选的（即这种类型的许多实例根本没有值）
* 模式和控制器是未知的（即它是一个扩展）
* 模式足够复杂（即，用它来增加主要类型的负担是没有意义的）
* 这种类型的访问控制需要比“所有状态”更细的粒度
* 分配值的生命周期与分配持有者的生命周期不同

服务和端点可以被认为是这种模式的一种形式，持久卷和持久卷声明也可以。

使用此模式时，您必须考虑已分配对象的生命周期（谁清理它们以及何时清理它们）以及它们与主类型之间的“链接”（通常使用相同的名称、对象引用字段或选择器）。

总会有一些情况可能遵循任一路径，这些需要人工评估来决定。例如，Service `clusterIP`与 Service 的其余部分高度耦合，并且大多数实例都使用它。但它也是严格可选的，并且相关领域的模式越来越复杂。对于任何一条路径都可以进行论证。
