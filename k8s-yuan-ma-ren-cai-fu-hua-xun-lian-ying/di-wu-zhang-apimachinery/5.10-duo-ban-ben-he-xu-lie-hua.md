# 5.10 多版本和序列化

## 前言

Apimachinery 主要完成两个工作，多版本转换和序列化，API多版本是Kubernetes API的重要特性，它跟一般应用的多版本API还不太一样，有它自己的特色，因此搞懂它的相关概念和实现原理是相当有必要的。

### 功能介绍 <a href="#gong-neng-jie-shao" id="gong-neng-jie-shao"></a>

Kubernetes API多版本这个特性跟很多其他应用的多版本API很不一样，首先就是它有分组的概念，即Group，因为Kubernetes有很多的资源，不太好统一管理，所以采取分而治之的方式，以组的方式去管理，而它的多版本是跟组关联的，即一个组可以同时有多个版本，即Version，而组内的资源种类，即Kind，通过多版本的方式去迭代进化，这三者在Kubernetes中经常合起来表示某个版本的某种资源，即 `GroupVersionKind`，简称 `GVK`；其次就是多版本之间的资源对象可以互相转换，这个是什么意思呢？即底层数据是同一份数据，但是根据调用API的版本不同，可以转换成对应版本的资源对象，比如有一个资源它现在有三个版本的API同时存在：v1, v1beta1, v1beta2，你通过调用v1beta1版本的API，创建了一个该对象，那你通过v1, v1beta1, v1beta2的API，均可以将该对象读出来，或者做其他的操作，那这个特性有什么用呢？谁会去把v1beta1版本的对象转成v1版本来用呢？这是我看到这个特性时，脑海中的第一个问题，通过阅读[官方文档](https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning)可以知道，其实这个特性完全是为了保持API的兼容而设计的，正常情况下，没有人会混着版本去用，它发挥作用的地方主要在升级迭代时，要知道随着API的迭代开发，API会逐渐GA进入到稳定版本，那beta版，以及alpha版则会在某一个阶段被移除，这时候，你用beta版API创建的资源对象，仍然能够用稳定版API来操作，这样就实现了无缝升级。
