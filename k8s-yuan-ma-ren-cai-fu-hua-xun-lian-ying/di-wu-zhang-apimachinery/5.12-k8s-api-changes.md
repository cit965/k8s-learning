# 5.12 k8s api-changes

## So you want to change the API?

在尝试更改 API 之前，您应该熟悉一些现有的 API 类型和[API 约定](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md)。如果创建新的 API 类型/资源，我们还建议您首先发送仅包含新 API 类型提案的 PR。

Kubernetes API 有两个主要组件 - 内部结构和版本化 API。版本化 API 的目的是稳定，而内部结构的实现是为了最好地反映 Kubernetes 代码本身的需求。

对于 API 更改来说，这意味着您必须在处理更改的方式上深思熟虑，并且必须接触多个部分才能做出完整的更改。本文档旨在指导您完成整个过程，但并非所有 API 更改都需要所有这些步骤。

## Operational overview

为了浏览本文档的其余部分，对 Kubernetes 中使用的 API 系统有一个深入的了解非常重要。

如上所述，API 对象的内部表示与任何一个 API 版本是解耦的。这提供了很大的自由来发展代码，但它需要强大的基础设施来在表示之间进行转换。处理 API 操作有多个步骤 - 即使像 GET 这样简单的操作也涉及大量的机制。

这个转换过程在逻辑上是一个以内部形式为中心的“星”。每个版本化 API 都可以转换为内部形式（反之亦然），但版本化 API 不会直接转换为其他版本化 API。这听起来像是一个繁重的过程，但实际上我们并不打算同时保留少量版本。虽然所有 Kubernetes 代码都在内部结构上运行，但它们在写入存储（磁盘或 etcd）或通过线路发送之前始终会转换为版本化形式。客户端应专门使用和操作版本化 API。

为了演示一般过程，这里有一个（假设的）示例：

1. 用户将`Pod`对象发布到`/api/v7beta1/...`
2. JSON 被解组为`v7beta1.Pod`结构
3. 默认值应用于`v7beta1.Pod`
4. `v7beta1.Pod`转换为`api.Pod`结构
5. `api.Pod`已验证，任何错误都会返回给用户
6. `api.Pod`转换为`v6.Pod` （因为 v6 是最新的稳定版本）
7. `v6.Pod`被编组为 JSON 并写入 etcd

现在我们已经存储了`Pod`对象，用户可以在任何受支持的 api 版本中获取该对象。例如：

1. 用户从`/api/v5/...`获取`Pod`
2. JSON 从 etcd 读取并解组为`v6.Pod`结构
3. 默认值应用于`v6.Pod`
4. `v6.Pod`转换为`api.Pod`结构
5. `api.Pod`转换为`v5.Pod`结构
6. `v5.Pod`被编组为 JSON 并发送给用户

此过程的含义是 API 更改必须谨慎且向后兼容。

### On compatibility&#x20;

在讨论如何更改 API 之前，有必要先澄清一下 API 兼容性的含义。 Kubernetes 将其 API 的向前和向后兼容性视为首要任务。兼容性很_困难_，尤其是处理回滚安全方面的问题。这是每次 API 更改都必须考虑的事情。

如果 API 更改满足以下条件，则视为兼容：

* 添加了正确行为不需要的新功能（例如，不添加新的必填字段）
* 不改变现有的语义，包括：
  * 默认值_和行为_的语义含义
  * 现有 API 类型、字段和值的解释
  * 哪些字段是必填字段，哪些字段不是
  * 可变字段不会变得不可变
  * valid values do not become invalid
  * 明确无效的值不会变得有效

换句话说：

1. 在更改之前成功的任何 API 调用（例如，发布到 REST 端点的结构）在更改之后也必须成功。
2. 任何不使用您的更改的 API 调用的行为都必须与更改之前的行为相同。
3. 当针对不包含您的更改的 API 服务器发出任何使用您的更改的 API 调用时，不得导致问题（例如崩溃或降级行为）。
4. 必须能够往返更改（转换为不同的 API 版本并返回）而不会丢失信息。
5. 现有客户无需知道您的更改，即可继续像以前一样运行，即使您的更改正在使用中也是如此。
6. 必须能够回滚到不包含您的更改的 API 服务器的先前版本，并且对不使用您的更改的 API 对象没有影响。如果回滚，使用您的更改的 API 对象将受到影响。

如果您的更改不符合这些标准，则不会被视为兼容，并且可能会破坏旧客户端，或导致新客户端导致未定义的行为。此类更改通常是不允许的，但在极端情况下（例如安全或明显的错误）也有例外。

让我们考虑一些例子。

#### Adding a field&#x20;

在假设的 API 中（假设我们使用的是 v6 版本）， `Frobber`结构如下所示：

```go
// API v6.
type Frobber struct {
  Height int    `json:"height"`
  Param  string `json:"param"`
}
```

您想要添加新的`Width`字段。一般允许在不改变API版本的情况下添加新字段，因此只需将其更改为：

```go
// Still API v6.
type Frobber struct {
  Height int    `json:"height"`
  Width  int    `json:"width"`
  Param  string `json:"param"`
}
```

您有责任为`Width`定义一个合理的默认值，以使上面的规则 #1 和 #2 成立 - API 调用和曾经有效的存储对象必须继续有效。

#### Making a singular field plural

对于下一次更改，您希望允许多个`Param`值。您不能简单地删除`Param string`并添加`Params []string` （而不创建全新的 API 版本） - 这会违反规则 #1、#2、#3 和 #6。您也不能简单地添加`Params []string`并使用它 - 这会失败 #2 和 #6。

您必须定义一个新字段以及该字段与现有字段之间的关系。首先添加新的复数字段：

```go
// Still API v6.
type Frobber struct {
  Height int           `json:"height"`
  Width  int           `json:"width"`
  Param  string        `json:"param"`  // the first param
  Params []string      `json:"params"` // all of the params
}
```

这个新字段必须包含 singular 字段。为了满足兼容性规则，您必须处理版本倾斜、多个客户端和回滚的所有情况。这可以通过准入控制或 API 注册逻辑（例如策略）将字段与来自 API 操作的上下文链接在一起来处理，以尽可能接近用户的意图。

**Upon any read operation: 任何读取操作时：**

如果未填充plural，API 逻辑必须将plural 填充为单元素列表，并将plural\[0] 设置为单数值。

**Upon any create operation: 进行任何创建操作时：**

* 如果仅指定单数字段（例如较旧的客户端），API 逻辑必须将复数填充为单元素列表，并将plural\[0] 设置为单数值。理由：这是一个老客户，他们的行为兼容。
* 如果同时指定了单数和复数字段，API 逻辑必须验证plural\[0] 是否与单数值匹配。
* 任何其他情况都是错误，必须被拒绝。这包括指定复数字段和不指定单数字段的情况。理由：在更新中，不可能区分旧客户端通过补丁清除单数字段和新客户端设置复数字段之间的区别。为了兼容性，我们必须假设前者，并且我们不希望更新语义与创建不同（请参见下面的[单双歧义](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api\_changes.md#single\_dual\_ambiguity)。

对于上述内容：“已指定”表示该字段存在于用户提供的输入中（包括默认字段）。

**Upon any update operation (including patch): 进行任何更新操作（包括补丁）时：**

* 如果单数被清除并且复数没有改变，API逻辑必须清除复数。理由：这是一个老客户清理它所知道的领域。
* 如果复数被清除且单数未更改，API 逻辑必须使用与旧复数相同的值填充新复数。理由：这是一个旧客户端，无法发送它不知道的字段。
* 如果单数字段已更改（但未清除）并且复数字段未更改，API 逻辑必须将plural 填充为单元素列表，并将plural\[0] 设置为单数值。理由：这是一个老客户改变了他们所了解的领域。

用代码表示，如下所示：

```go
// normalizeParams adjusts Params based on Param.  This must not consider
// any other fields.
func normalizeParams(after, before *api.Frobber) {
     // Validation  will be called on the new object soon enough.  All this
     // needs to do is try to divine what user meant with these linked fields.
     // The below is verbosely written for clarity.

     // **** IMPORTANT *****
     // As a governing rule. User must either:
     //   a) Use singular field only (old client)
     //   b) Use singular *and* plural fields (new client)

     if before == nil {
         // This was a create operation.

         // User specified singular and not plural (an old client), so we can
         // init plural for them.
         if len(after.Param) > 0 && len(after.Params) == 0 {
             after.Params = []string{after.Param}
             return
         }

         // Either both were specified or both were not.  Catch this in
         // validation.
         return
     }

     // This was an update operation.

     // Plural was cleared by an old client which was trying to patch
     // some field and didn't provide it.
     if len(before.Params) > 0 && len(after.Params) == 0 {
         // If singular is unchanged, then it is an old client trying to
         // patch, and didn't provide plural.  Bring the old value forward.
         if before.Param == after.Param {
             after.Params = before.Params
         }
     }

     if before.Param != after.Param {
         // Singular is changed.

         if len(before.Param) > 0 && len(after.Param) == 0 {
             // If singular was cleared and plural is unchanged, then we can
             // clear plural to match.
             if sameStringSlice(before.Params, after.Params) {
                 after.Params = nil
             }
             // Else they also changed plural - check it in validation.
         } else {
             // If singular was changed (but not cleared) and plural was not,
             // then we can set plural based on singular (same as create).
             if sameStringSlice(before.Params, after.Params) {
                 after.Params = []string{after.Param}
             }
         }
     }
 }
```

只知道单一领域的老客户将继续取得成功，并产生与变革之前相同的结果。新客户可以使用您的更改，而不会影响老客户。 API 服务器可以回滚，只有使用您的更改的对象才会受到影响。

对 API 进行版本控制以及使用不同于任何一个版本的内部类型的部分原因是为了处理这样的增长。内部表示可以实现为：

```go
// Internal, soon to be v7beta1.
type Frobber struct {
  Height int
  Width  int
  Params []string
}
```

## **Single-Dual ambiguity 单双歧义**

假设用户开始于：

```bash
kind: Frobber
height: 42
width: 3
param: "super"
```

在创建时我们可以设置`params: ["super"]` 。

在不相关的 POST（又名替换）中，旧客户端会发送：

```bash
kind: Frobber
height: 3
width: 42
param: "super"
```

如果我们不要求新客户端同时使用单数和复数字段，则新客户端将发送：

这似乎很清楚 - 我们可以假设`param: "super"` 。

但旧客户端可以通过补丁发送此内容：

```bash
PATCH  /frobbers/1
{ param: "" }
```

在注册表代码可以看到它之前，它会应用于旧对象，我们最终得到：

```bash
kind: Frobber
height: 42
width: 3
params: ["super"]
```

按照前面的逻辑，我们将`params[0]`复制到`param`并最终得到`param: "super"` 。但这不是用户想要的，更重要的是与我们多元化之前发生的情况不同。

为了消除歧义，我们要求复数用户也始终指定单数。

#### Multiple API versions 多个API版本

我们已经了解了如何满足规则#1、#2 和#3。规则 #4 意味着您无法在不扩展其他 API 的情况下扩展一个版本化 API。例如，API 调用可能会以 API v7beta1 格式发布一个对象，该格式使用新的`Params`字段，但 API 服务器可能会以可靠的旧 v6 形式存储该对象（因为 v7beta1 是“beta”）。当用户在 v7beta1 API 中读回对象时，丢失除`Params[0]`之外的所有对象是不可接受的。这意味着，即使它很丑陋，也必须对 v6 API 进行兼容的更改，如上所述。

对于某些更改，正确执行此操作可能具有挑战性。它可能需要同一 API 资源中相同信息的多种表示形式，这些表示形式需要保持同步才能更改。

例如，假设您决定重命名同一 API 版本中的字段。在这种情况下，您可以为`height`和`width`添加单位。您可以通过添加新字段来实现这一点：

```go
type Frobber struct {
  Height         *int          `json:"height"`
  Width          *int          `json:"width"`
  HeightInInches *int          `json:"heightInInches"`
  WidthInInches  *int          `json:"widthInInches"`
}
```

您将所有字段转换为指针，以便区分未设置和设置为 0，然后在默认逻辑中设置每个相应的字段（例如`heightInInches`为`height` ，反之亦然）。当用户创建发送手写配置时，效果很好——客户端可以写入任一字段并读取任一字段。

但是，如何从 GET 的输出创建或更新，或者通过 PATCH 更新（请参阅[就地更新](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#in-place-updates-of-resources)）？在这些情况下，这两个字段将发生冲突，因为如果旧客户端只知道旧字段（例如`height` ），则只会更新一个字段。

假设客户端创建：

```go
{
  "height": 10,
  "width": 5
}
```

and GETs: 和获取：

```go
{
  "height": 10,
  "heightInInches": 10,
  "width": 5,
  "widthInInches": 5
}
```

then PUTs back: 然后放回去：

```go
{
  "height": 13,
  "heightInInches": 10,
  "width": 5,
  "widthInInches": 5
}
```

根据兼容性规则，更新不得失败，因为它在更改之前就可以工作。

### 向后兼容性陷阱

* 单个功能/属性无法在 API 版本中同时使用多个规范字段来表示。一次只能填充一种表示，并且客户端需要能够指定他们希望在突变和读取时使用哪个字段（通常通过 API 版本）。如上所述，老客户端必须继续正常运行。
* 即使在新的 API 版本中，新的表示形式也比旧的表示形式更具表现力，这会破坏向后兼容性，因为仅理解旧表示形式的客户端不会意识到新的表示形式及其语义。遇到这一挑战的提案示例包括[通用标签选择器](http://issues.k8s.io/341)和[Pod 级安全上下文](http://prs.k8s.io/12823)。
* 枚举值会带来类似的挑战。将新值添加到枚举集_不是_兼容的更改。假设他们知道如何处理给定字段的所有可能值的客户端将无法处理新值。但是，如果处理得当，从枚举集中删除值_可能_是兼容的更改（将删除的值视为已弃用但允许）。对于期望在未来添加新值的类似枚举的字段（例如`reason`字段），请在该字段可用的第一个版本的 API 字段描述中清楚地记录该期望，并描述客户端应如何处理未知值。客户应将此类价值观视为潜在的开放式价值观。
* 对于[Unions](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#unions)来说，最多应设置一个字段的集合，如果在原始对象中遵循[适当的约定，](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#objects)则可以向联合添加新选项。删除选项需要遵循[弃用流程](https://kubernetes.io/docs/reference/deprecation-policy/)。
* 更改任何验证规则总是有可能破坏某些客户端，因为它改变了有关部分 API 的假设，类似于添加新的枚举值。规范字段的验证规则既不能放松也不能加强。不允许强化，因为任何以前有效的请求都必须继续有效。弱化验证有可能破坏 API 资源的其他使用者和生成者。状态字段的写入者在我们的控制之下（例如，由不可插入的控制器写入），可能会加强验证，因为这将导致客户端可以观察到先前有效值的子集。
* 不要添加现有资源的新 API 版本并将其设为同一版本中的首选版本，也不要将其设为存储版本。后者是必要的，这样 apiserver 的回滚不会使 etcd 中的资源在回滚后变得不可解码。
* 在一个 API 版本中具有默认值的任何字段在所有 API 版本中都必须具有_非零_默认值。这可以分为2种情况：
  * 为现有的非默认字段添加具有默认值的新 API 版本：需要添加语义上等同于在所有以前的 API 版本中未设置的默认值，以保留未设置值的语义含义。
  * 添加具有默认值的新字段：默认值在所有当前支持的 API 版本中必须在语义上等效。

### Incompatible API changes 不兼容的 API 更改

有时，不兼容的更改可能没问题，但大多数情况下我们希望更改满足上述定义。如果您认为需要破坏兼容性，您应该首先与 Kubernetes API 审阅者交谈。

破坏测试版或稳定 API 版本（例如 v1）的兼容性是不可接受的。实验性或 alpha API 的兼容性并不是严格要求的，但不应该轻易破坏兼容性，因为它会破坏该功能的所有用户。 Alpha 和 Beta API 版本可能会被弃用并最终批量删除，如[弃用政策](https://kubernetes.io/docs/reference/deprecation-policy/)中所述。

果您的更改将向后不兼容或者可能对 API 使用者来说是重大更改，请在更改生效之前向`dev@kubernetes.io`发送公告。如果您不确定，请询问。还要确保通过使用“release-note-action-required”github 标签标记 PR，将更改记录在下一个版本的发行说明中。

如果您发现您的更改意外破坏了客户端，则应将其恢复。

简而言之，预期的 API 演变如下：

* `newapigroup/v1alpha1` -> ... -> `newapigroup/v1alphaN` ->
* `newapigroup/v1beta1` -> ... -> `newapigroup/v1betaN` ->
* `newapigroup/v1` ->
* `newapigroup/v2alpha1` -> ...

在 alpha 阶段，我们希望继续推进它，但也可能会打破它。

一旦进入测试版，我们将保留向前兼容性，但可能会引入新版本并删除旧版本。

v1 必须在较长时间内向后兼容。

## Changing versioned APIs 更改版本化 API

对于大多数更改，您可能会发现首先更改版本化 API 是最简单的。这迫使您思考如何以兼容的方式进行更改。与在每个版本中执行每个步骤相比，一次执行每个版本化 API 或在开始“其余所有”之前执行一个版本的所有操作通常更容易。

### Edit types.go 编辑 types.go 

每个 API 的结构定义位于 `staging/src/k8s.io/api/<group>/<version>/types.go` 。编辑这些文件以反映您想要进行的更改。请注意，版本化 API 中的所有类型和非内联字段之前都必须有描述性注释 - 这些用于生成文档。类型的注释不应包含类型名称； API 文档是根据这些注释生成的，最终用户不应该接触 golang 类型名称。

对于需要生成[DeepCopyObject](https://github.com/kubernetes/kubernetes/commit/8dd0989b395b29b872e1f5e06934721863e4a210#diff-6318847735efb6fae447e7dbf198c8b2R3767)方法的类型（通常仅由像`Pod`这样的顶级类型需要），请将此行添加到注释中（[示例](https://github.com/kubernetes/kubernetes/commit/39d95b9b065fffebe5b6f233d978fe1723722085#diff-ab819c2e7a94a3521aecf6b477f9b2a7R30)）：

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

可选字段应具有`,omitempty` json 标签；否则字段将被解释为必需的。

#### Edit defaults.go 编辑defaults.go

如果您的更改包括需要默认值的新字段，则需要将案例添加到 `pkg/apis/<group>/<version>/defaults.go` 。

**注意：**为新字段添加默认值时，您还_必须_在所有 API 版本中添加默认值，而不是在旧 API 版本中保留新字段未设置（例如`nil` ）。这是必需的，因为每当读取序列化版本时就会发生默认设置（请参阅[#66135](https://github.com/kubernetes/kubernetes/issues/66135) ）。如果可能，选择有意义的值作为未设置值的标记。

过去，Core v1 API 很特殊。它的`defaults.go`曾经位于`pkg/api/v1/defaults.go` 。如果您看到引用该路径的代码，则可以确定它已过时。现在核心 v1 api 位于`pkg/apis/core/v1/defaults.go`它遵循上述约定。

当然，既然添加了代码，就得添加测试： `pkg/apis/<group>/<version>/defaults_test.go` 。

当您需要区分未设置的值和自动归零值时，请使用指向标量的指针。例如， `PodSpec.TerminationGracePeriodSeconds` 定义为`*int64` go 类型定义。零值表示 0 秒，零值要求系统选择默认值。

不要忘记运行测试！

#### Edit conversion.go 编辑 conversion.go

鉴于您尚未更改内部结构，这可能感觉为时过早，但事实确实如此。您还没有任何可转换的内容。我们将在“内部”部分重新讨论这一点。如果您以不同的顺序执行这一切（即您从内部结构开始），那么您应该跳到下面的该主题。在极少数情况下，您正在进行不兼容的更改，您现在可能想也可能不想这样做，但稍后您必须做更多的事情。你想要的文件是 `pkg/apis/<group>/<version>/conversion.go` 和 `pkg/apis/<group>/<version>/conversion_test.go` 。

请注意，转换机制一般不处理值的转换，例如各种字段引用和 API 常量。[客户端库](https://github.com/kubernetes/client-go/blob/v4.0.0-beta.0/rest/request.go#L352)具有用于字段引用的自定义转换代码。您还需要使用支持翻译的映射函数添加对方案的`AddFieldLabelConversionFunc`的调用，如这一[行](https://github.com/kubernetes/kubernetes/blob/v1.8.0-alpha.2/pkg/api/v1/conversion.go#L165)。

### 改变内部结构

在是时候更改内部结构了，以便可以使用版本化的更改。

与版本化 API 类似，内部结构的定义位于`pkg/apis/<group>/types.go`中。编辑这些文件以反映您想要进行的更改。请记住，内部结构必须能够表达_所有_版本化 API。

与版本化 API 类似，您需要将`+k8s:deepcopy-gen`标记添加到需要生成 DeepCopyObject 方法的类型。

### Edit validation.go 编辑validation.go

对内部结构所做的大多数更改都需要某种形式的输入验证。目前对内部对象进行验证 `pkg/apis/<group>/validation/validation.go` 。此验证是我们创造良好用户体验的首要机会之一 - 良好的错误消息和彻底的验证有助于确保用户提供您所期望的内容，并且当他们没有提供时，他们知道原因以及如何修复它。认真思考`string`字段的内容、 `int`字段的边界以及字段的可选性。

### Edit version conversions 编辑版本转换

此时，您已完成版本化 API 更改和内部结构更改。如果存在任何显着差异（尤其是字段名称、类型、结构更改），则必须添加一些逻辑来将版本化 API 与内部表示形式相互转换。如果您在`serialization_test`中看到错误，则可能表明需要显式转换。

转换的性能很大程度上影响 apiserver 的性能。因此，我们自动生成的转换函数比通用函数（基于反射，因此效率非常低）要高效得多。

转换代码驻留在每个版本化的 API 中。有两个文件：

* `pkg/apis/<group>/<version>/conversion.go` 包含手动编写的转换函数
* `pkg/apis/<group>/<version>/zz_generated.conversion.go` 包含自动生成的转换函数

由于自动生成的转换函数使用手动编写的函数，因此手动编写的转换函数应按照定义的约定命名，即将 pkg `a`中的类型`X`转换为 pkg `b`中的类型`Y`函数应命名为： `convert_a_X_To_b_Y` 。

另请注意，在编写转换函数时，您可以（并且出于效率原因应该）使用自动生成的转换函数。

添加手动编写的转换还需要您添加测试 `pkg/apis/<group>/<version>/conversion_test.go` 。

添加所有必要的手动编写的转换后，您需要重新生成自动生成的转换。要重新生成它们，请运行：

```bash
make clean && make generated_files
```

`make clean`很重要，否则生成的文件可能会过时，因为构建系统使用自定义缓存。

`make all`也会调用`make generated_files` 。

`make generated_files`还将重新生成`zz_generated.deepcopy.go` 、 `zz_generated.defaults.go`和`api/openapi-spec/swagger.json` 。

如果由于编译错误而无法重新生成，最简单的解决方法是删除导致错误的文件并重新运行命令。

### Generate Code 生成代码

除了`defaulter-gen` 、 `deepcopy-gen` 、 `conversion-gen`和`openapi-gen`之外，还有一些其他的生成器：

* `go-to-protobuf`
* `client-gen`
* `lister-gen`
* `informer-gen`
* `codecgen` (for fast json serialization with ugorji codec)

许多生成器都基于[`gengo`](https://github.com/kubernetes/gengo)并共享公共标志。 `--verify-only`标志将检查磁盘上的现有文件，如果它们不是本来会生成的文件，则会失败。

创建 go 代码的生成器有一个`--go-header-file`标志，该标志应该是包含应包含的标头的文件。此标头是应出现在生成文件顶部的版权，并应与构建后期阶段的脚本。

要调用这些生成器，您可以运行`make update` ，它会运行一堆[脚本](https://github.com/kubernetes/kubernetes/blob/release-1.23/hack/make-rules/update.sh#L47-L55)。请继续阅读接下来的几节，因为某些生成器有先决条件，也因为它们介绍了如果您发现`make update`运行时间太长，如何单独调用生成器。

#### 生成protobuf对象

对于任何核心 API 对象，我们还需要生成 Protobuf IDL 和编组器。那一代人被调用

```
hack/update-generated-protobuf.sh
```

绝大多数对象在转换为 protobuf 时不需要任何考虑，但请注意，如果您依赖于标准库中的 Golang 类型，则可能需要额外的工作，尽管在实践中我们通常使用自己的等效项进行 JSON 序列化。 `pkg/api/serialization_test.go`将验证您的 protobuf 序列化是否保留了所有字段 - 请务必运行多次以确保没有不完整计算的字段。

#### Generate Clientset 生成客户集

`client-gen`是一个为顶级 API 对象生成客户端集的工具。

`client-gen`需要在内部`pkg/apis/<group>/types.go`以及每个特定版本中的每个导出类型上`// +genclient`注释 `staging/src/k8s.io/api/<group>/<version>/types.go` 。

如果 apiserver 将您的 API 托管在与文件系统中的`<group>`不同的组名下（通常这是因为文件系统中的`<group>`省略了“k8s.io”后缀，例如，admission 与 grant）。 k8s.io），您可以通过在内部`pkg/apis/<group>/doc.go` `doc.go`中添加`// +groupName=`注释来指示`client-gen`使用正确的组名称就像每个特定版本一样 `staging/src/k8s.io/api/<group>/<version>/types.go` 。

添加注释后，使用以下命令生成客户端

```
hack/update-codegen.sh
```

请注意，您可以使用可选的`// +groupGoName=`指定 CamelCase 自定义 Golang 标识符来消除冲突，例如`policy.authorization.k8s.io`和`policy.k8s.io` 。这两个都将映射到客户端集中的`Policy()` 。

client-gen 很灵活。如果您需要非 kubernetes API 的 client-gen，请参阅[此文档](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/generating-clientset.md)。

#### Generate Listers 生成列表

`lister-gen`是一个为客户端生成列表的工具。它重用了`//+genclient`和`// +groupName=`注释，因此您不需要指定额外的注释。

您之前运行的`hack/update-codegen.sh`已调用`lister-gen` 。

#### Generate Informers 生成告密者

`informer-gen`生成非常有用的 Informer，用于监视 API 资源的变化。它重用了`//+genclient`和`//+groupName=`注释，因此您不需要指定额外的注释。

#### 编辑 json（取消）编组代码

我们正在自动生成用于封送和解封 api 对象的 json 表示的代码 - 这是为了提高整体系统性能。

自动生成的代码驻留在每个版本化 API 中：

* `staging/src/k8s.io/api/<group>/<version>/generated.proto`
* `staging/src/k8s.io/api/<group>/<version>/generated.pb.go`

要重新生成它们，请运行：

```
hack/update-generated-protobuf.sh
```
