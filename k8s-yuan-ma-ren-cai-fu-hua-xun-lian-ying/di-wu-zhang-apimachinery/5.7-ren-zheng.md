# 5.7 认证

## 身份认证策略

Kubernetes 使用身份认证插件利用客户端证书、持有者令牌（Bearer Token）、身份认证代理（Proxy） 或者 HTTP 基本认证机制来认证 API 请求的身份。HTTP 请求发给 API 服务器时， 插件会将以下属性关联到请求本身：

* 用户名：用来辩识最终用户的字符串。常见的值可以是 `kube-admin` 或 `jane@example.com`。
* 用户 ID：用来辩识最终用户的字符串，旨在比用户名有更好的一致性和唯一性。
* 用户组：取值为一组字符串，其中各个字符串用来标明用户是某个命名的用户逻辑集合的成员。 常见的值可能是 `system:masters` 或者 `devops-team` 等。
* 附加字段：一组额外的键-值映射，键是字符串，值是一组字符串；用来保存一些鉴权组件可能 觉得有用的额外信息。

与其它身份认证协议（LDAP、SAML、Kerberos、X509 的替代模式等等）都可以通过 使用一个身份认证代理或 身份认证 Webhoook来实现。

## 流程

当客户端发送请求到达APIServer端，请求首先进入认证环节，对应处理认证的是Authentication Handler方法，

Authentication Handler方法中，遍历每一个已启用的认证器，仅需某一个认证器返回true，则认证成功结束遍历，若所有认证器全部返回false，则认证失败。

## 代码位置

构建server之前，生成通用配置buildGenericConfig里

```go
// pkg/controlplane/apiserver/config.go

// Authentication.ApplyTo requires already applied OpenAPIConfig and EgressSelector if present
if lastErr = s.Authentication.ApplyTo(&genericConfig.Authentication, genericConfig.SecureServing, genericConfig.EgressSelector, genericConfig.OpenAPIConfig, clientgoExternalClient, versionedInformers); lastErr != nil {
	return
}

func ApplyTo(){

	//... 省略
	authenticatorConfig.New(ctx)
	// ... 省略
}

// New returns an authenticator.Request or an error that supports the standard
// Kubernetes authentication mechanisms.
func (config Config) New(serverLifecycle context.Context) (authenticator.Request, func(context.Context, *apiserver.AuthenticationConfiguration) error, *spec.SecurityDefinitions, spec3.SecuritySchemes, error) {
    var authenticators []authenticator.Request
    var tokenAuthenticators []authenticator.Token
    securityDefinitionsV2 := spec.SecurityDefinitions{}
    securitySchemesV3 := spec3.SecuritySchemes{}

    // front-proxy, BasicAuth methods, local first, then remote
    // Add the front proxy authenticator if requested
    if config.RequestHeaderConfig != nil {
       requestHeaderAuthenticator := headerrequest.NewDynamicVerifyOptionsSecure(
          config.RequestHeaderConfig.CAContentProvider.VerifyOptions,
          config.RequestHeaderConfig.AllowedClientNames,
          config.RequestHeaderConfig.UsernameHeaders,
          config.RequestHeaderConfig.UIDHeaders,
          config.RequestHeaderConfig.GroupHeaders,
          config.RequestHeaderConfig.ExtraHeaderPrefixes,
       )
       authenticators = append(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, requestHeaderAuthenticator))
    }

    // X509 methods
    if config.ClientCAContentProvider != nil {
       certAuth := x509.NewDynamic(config.ClientCAContentProvider.VerifyOptions, x509.CommonNameUserConversion)
       authenticators = append(authenticators, certAuth)
    }

    // Bearer token methods, local first, then remote
    if len(config.TokenAuthFile) > 0 {
       tokenAuth, err := newAuthenticatorFromTokenFile(config.TokenAuthFile)
       if err != nil {
          return nil, nil, nil, nil, err
       }
       tokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))
    }
    if config.ServiceAccountPublicKeysGetter != nil {
       serviceAccountAuth, err := newLegacyServiceAccountAuthenticator(config.ServiceAccountPublicKeysGetter, config.ServiceAccountLookup, config.APIAudiences, config.ServiceAccountTokenGetter, config.SecretsWriter)
       if err != nil {
          return nil, nil, nil, nil, err
       }
       tokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)
    }
    if len(config.ServiceAccountIssuers) > 0 && config.ServiceAccountPublicKeysGetter != nil {
       serviceAccountAuth, err := newServiceAccountAuthenticator(config.ServiceAccountIssuers, config.ServiceAccountPublicKeysGetter, config.APIAudiences, config.ServiceAccountTokenGetter)
       if err != nil {
          return nil, nil, nil, nil, err
       }
       tokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)
    }

    if config.BootstrapToken && config.BootstrapTokenAuthenticator != nil {
       tokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, config.BootstrapTokenAuthenticator))
    }

    // NOTE(ericchiang): Keep the OpenID Connect after Service Accounts.
    //
    // Because both plugins verify JWTs whichever comes first in the union experiences
    // cache misses for all requests using the other. While the service account plugin
    // simply returns an error, the OpenID Connect plugin may query the provider to
    // update the keys, causing performance hits.
    var updateAuthenticationConfig func(context.Context, *apiserver.AuthenticationConfiguration) error
    if config.AuthenticationConfig != nil {
       initialJWTAuthenticator, err := newJWTAuthenticator(serverLifecycle, config.AuthenticationConfig, config.OIDCSigningAlgs, config.APIAudiences, config.ServiceAccountIssuers)
       if err != nil {
          return nil, nil, nil, nil, err
       }

       jwtAuthenticatorPtr := &atomic.Pointer[jwtAuthenticatorWithCancel]{}
       jwtAuthenticatorPtr.Store(initialJWTAuthenticator)

       updateAuthenticationConfig = (&authenticationConfigUpdater{
          serverLifecycle:     serverLifecycle,
          config:              config,
          jwtAuthenticatorPtr: jwtAuthenticatorPtr,
       }).updateAuthenticationConfig

       tokenAuthenticators = append(tokenAuthenticators,
          authenticator.TokenFunc(func(ctx context.Context, token string) (*authenticator.Response, bool, error) {
             return jwtAuthenticatorPtr.Load().jwtAuthenticator.AuthenticateToken(ctx, token)
          }),
       )
    }

    if len(config.WebhookTokenAuthnConfigFile) > 0 {
       webhookTokenAuth, err := newWebhookTokenAuthenticator(config)
       if err != nil {
          return nil, nil, nil, nil, err
       }

       tokenAuthenticators = append(tokenAuthenticators, webhookTokenAuth)
    }

    if len(tokenAuthenticators) > 0 {
       // Union the token authenticators
       tokenAuth := tokenunion.New(tokenAuthenticators...)
       // Optionally cache authentication results
       if config.TokenSuccessCacheTTL > 0 || config.TokenFailureCacheTTL > 0 {
          tokenAuth = tokencache.New(tokenAuth, true, config.TokenSuccessCacheTTL, config.TokenFailureCacheTTL)
       }
       authenticators = append(authenticators, bearertoken.New(tokenAuth), websocket.NewProtocolAuthenticator(tokenAuth))

       securityDefinitionsV2["BearerToken"] = &spec.SecurityScheme{
          SecuritySchemeProps: spec.SecuritySchemeProps{
             Type:        "apiKey",
             Name:        "authorization",
             In:          "header",
             Description: "Bearer Token authentication",
          },
       }
       securitySchemesV3["BearerToken"] = &spec3.SecurityScheme{
          SecuritySchemeProps: spec3.SecuritySchemeProps{
             Type:        "apiKey",
             Name:        "authorization",
             In:          "header",
             Description: "Bearer Token authentication",
          },
       }
    }

    if len(authenticators) == 0 {
       if config.Anonymous.Enabled {
          return anonymous.NewAuthenticator(config.Anonymous.Conditions), nil, &securityDefinitionsV2, securitySchemesV3, nil
       }
       return nil, nil, &securityDefinitionsV2, securitySchemesV3, nil
    }

    authenticator := union.New(authenticators...)

    authenticator = group.NewAuthenticatedGroupAdder(authenticator)

    if config.Anonymous.Enabled {
       // If the authenticator chain returns an error, return an error (don't consider a bad bearer token
       // or invalid username/password combination anonymous).
       authenticator = union.NewFailOnError(authenticator, anonymous.NewAuthenticator(config.Anonymous.Conditions))
    }

    return authenticator, updateAuthenticationConfig, &securityDefinitionsV2, securitySchemesV3, nil
}


```



## RequestHeader认证

一种代理认证方式，需要再apiserver启动时以参数形式配置，来看看官方的介绍：

API 服务器可以配置成从请求的头部字段值（如 `X-Remote-User`）中辩识用户。 这一设计是用来与某身份认证代理一起使用 API 服务器，代理负责设置请求的头部字段值。

* `--requestheader-username-headers` 必需字段，大小写不敏感。用来设置要获得用户身份所要检查的头部字段名称列表（有序）。第一个包含数值的字段会被用来提取用户名。
* `--requestheader-group-headers` 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。 建议设置为 "X-Remote-Group"。用来指定一组头部字段名称列表，以供检查用户所属的组名称。 所找到的全部头部字段的取值都会被用作用户组名。
* `--requestheader-extra-headers-prefix` 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。 建议设置为 "X-Remote-Extra-"。用来设置一个头部字段的前缀字符串，API 服务器会基于所给 前缀来查找与用户有关的一些额外信息。这些额外信息通常用于所配置的鉴权插件。 API 服务器会将与所给前缀匹配的头部字段过滤出来，去掉其前缀部分，将剩余部分 转换为小写字符串并在必要时执行[百分号解码](https://tools.ietf.org/html/rfc3986#section-2.1) 后，构造新的附加信息字段键名。原来的头部字段值直接作为附加信息字段的值。

例如，使用下面的配置：

```go
--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
```

针对所收到的如下请求：

```go
GET / HTTP/1.1
X-Remote-User: fido
X-Remote-Group: dogs
X-Remote-Group: dachshunds
X-Remote-Extra-Acme.com%2Fproject: some-project
X-Remote-Extra-Scopes: openid
X-Remote-Extra-Scopes: profile
```

会生成下面的用户信息：

```go
name: fido
groups:
- dogs
- dachshunds
extra:
  acme.com/project:
  - some-project
  scopes:
  - openid
  - profile
```

简而言之，就是在apiserver之前有一个代理服务器，通过代理服务器的名义，可以将相关的认证信息在请求头透传给apiserver，以通过apiserver的认证。代理服务的相关信息需要预先配置。

使用kubeadm默认部署的集群，就启用了requestheader的配置

## x509 CA认证

又称TLS双向认证，APIServer启动时使用--client-ca-file指定客户端的证书文件，用作请求的认证。

## BearerToken认证

这种认证方式是专为k8s节点准备的，避免每个节点都要手动配置TLS证书，在apiserver启动时指定`--enable-bootstrap-token-auth`参数来启用这种认证方式，详细说明见官方文档：

## ServiceAccount(SA)认证

启用方式为APIServer命令使用`--service-account-key-file`参数指定一个为token签名的PEM秘钥文件。

SA认证是jwt形式的认证，使用方式与bearer token类似，也是放在请求头里，内容为Base64编码，header格式为:

`Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0NTk0LCJ1c2VybmFtZSI6InlpbndlbnFpbiIsImV4cCI6MTU3MDY3NDEyNywiZW1haWwiOiIifQ.djC2w5l3IiXYv7slZtGzlMzLc3_oPuR1M0dM9FwoaUU`

token哪里来呢？答案就是ServiceAccount。

SA是一种面向集群内部应用需要调用APIServer的场景所设计的认证方式。在创建ServiceAccount资源时，可以显示地设置标签将ServiceAccount绑定给某Deploy/sts/pod，也可以在Deploy/sts/pod的声明文件里显示指定ServiceAccount。ServiceAccount会自动创建Secret资源，token秘钥存放其中。

在相应的容器层面，token信息会被挂载进容器中，包含3个文件：

* namespace文件：指明命名空间
* ca.crt文件：APIServer的公钥证书，容器用来校验APIServer
* token文件: 存放在Secret里的JWT token

## WebhookToken认证

Webhook 身份认证是一种用来验证持有者令牌的回调机制。

* `--authentication-token-webhook-config-file` 指向一个配置文件，其中描述 如何访问远程的 Webhook 服务。
* `--authentication-token-webhook-cache-ttl` 用来设定身份认证决定的缓存时间。 默认时长为 2 分钟。

配置文件使用 [kubeconfig](https://kubernetes.io/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/) 文件的格式。文件中，`clusters` 指代远程服务，`users` 指代远程 API 服务 Webhook。下面是一个例子：

```
# Kubernetes API 版本
apiVersion: v1
# API 对象类别
kind: Config
# clusters 指代远程服务
clusters:
  - name: name-of-remote-authn-service
    cluster:
      certificate-authority: /path/to/ca.pem         # 用来验证远程服务的 CA
      server: https://authn.example.com/authenticate # 要查询的远程服务 URL。必须使用 'https'。

# users 指代 API 服务的 Webhook 配置
users:
  - name: name-of-api-server
    user:
      client-certificate: /path/to/cert.pem # Webhook 插件要使用的证书
      client-key: /path/to/key.pem          # 与证书匹配的密钥

# kubeconfig 文件需要一个上下文（Context），此上下文用于本 API 服务器
current-context: webhook
contexts:
- context:
    cluster: name-of-remote-authn-service
    user: name-of-api-sever
  name: webhook
```

当客户端尝试在 API 服务器上使用持有者令牌完成身份认证（ 如[前](https://kubernetes.io/zh/docs/reference/access-authn-authz/authentication/#putting-a-bearer-token-in-a-request)所述）时， 身份认证 Webhook 会用 POST 请求发送一个 JSON 序列化的对象到远程服务。 该对象是 `authentication.k8s.io/v1beta1` 组的 `TokenReview` 对象， 其中包含持有者令牌。 Kubernetes 不会强制请求提供此 HTTP 头部。

要注意的是，Webhook API 对象和其他 Kubernetes API 对象一样，也要受到同一 [版本兼容规则](https://kubernetes.io/zh/docs/concepts/overview/kubernetes-api/)约束。 实现者要了解对 Beta 阶段对象的兼容性承诺，并检查请求的 `apiVersion` 字段， 以确保数据结构能够正常反序列化解析。此外，API 服务器必须启用 `authentication.k8s.io/v1beta1` API 扩展组 （`--runtime-config=authentication.k8s.io/v1beta1=true`）。

POST 请求的 Body 部分将是如下格式：

```
{
  "apiVersion": "authentication.k8s.io/v1beta1",
  "kind": "TokenReview",
  "spec": {
    "token": "<持有者令牌>"
  }
}
```

远程服务应该会填充请求的 `status` 字段，以标明登录操作是否成功。 响应的 Body 中的 `spec` 字段会被忽略，因此可以省略。 如果持有者令牌验证成功，应该返回如下所示的响应：

```
{
  "apiVersion": "authentication.k8s.io/v1beta1",
  "kind": "TokenReview",
  "status": {
    "authenticated": true,
    "user": {
      "username": "janedoe@example.com",
      "uid": "42",
      "groups": [
        "developers",
        "qa"
      ],
      "extra": {
        "extrafield1": [
          "extravalue1",
          "extravalue2"
        ]
      }
    }
  }
}
```

而不成功的请求会返回：

```
{
  "apiVersion": "authentication.k8s.io/v1beta1",
  "kind": "TokenReview",
  "status": {
    "authenticated": false
  }
}
```
