# api-conventions

kubernetes api是一般的RESTful风格 – 通过HTTP动词（POST，PUT，DELETE和GET）实现对象的创建，更新，删除或查询 – 这些api优先接收和返回JSON。kubernetes也为非标准的动作暴露了额外的接口，允许额外的内容类型（译注：如log，exec）。所有接收和返回的JSON都有一个结构说明（schema），由“apiVersion”和“kind”这两个字段表示。

下面解释一下相关术语：

* **Kind** 特定对象的结构说明（如猫和狗有不同的属性与特性）
* **Resource** 使用JSON表示的系统实体对象，通过HTTP发送或接收。Resources的暴露通过：
  * Collections – 相同类型资源的列表，可以用来查询
  * Elements – 一个单独的资源，可以通过URL寻址
* **API Group** 暴露出来的一系列资源的集合，通过“apiVersion”字段来表示，如“policy.k8s.io/v1”

每个资源通常接收和返回单一类型（kind）。类型（kind）可以被多个资源（resources）接收和返回。例如，Pod类型通过“pods”资源暴露，允许用户创建，更新和删除pods，同时一个单独的“pod status”资源（that acts on “Pod” kind），允许自动化的程序来更新那个资源的部分子集字段。（译注：不同资源是在etcd分别存储的）

资源是和API组绑定在一起的 – 每个组可以有一个或多个版本，内个组下的不同版本下可以有一个或多个资源。组的名称通常使用域名表示，kubernetes项目本身保留使用了空的组名称、所有的单个单词名称以及所有已“\*.k8s.io”结尾的名称。当选择组的名称时，推荐使用你所在组织的子域名，例如“widget.mycompany.com”。

版本字符应该满足[DNS\_LABEL](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/identifiers.md)格式。

资源集合（resource collections）应全部使用小写字符，并且使用复数形式，而类型（kind）应该使用驼峰形式，并且使用单数形式。组必须使用先写形式，而且必须是合法的DNS子域名。

### 类型（Kinds）

类型分为三种不同的类别：

1. **Objects** 代表系统中的一个可持久化的（资源对象）实体。

一旦创建一个 API object，系统将确保资源存在。所有API对象都有通用的（common）元数据信息（译注：ObjectMeta）。

示例：`Pod`，`ReplicationSet`，`Service`，`Namespace`，`Node`。

2. **Lists**代表资源的集合，可以是一个（一般情况）类型或多个（偶尔）类型。列表（List）的名称必须以“List”结尾。列表可以有一组有限的通用元数据。所有的列表都使用必要的”items”字段容纳返回的实际对象列表。

系统内定义的大多数对象都应该有一个返回完整资源的接口，同时可以有返回部分列表的接口。一些对象可能是单例的（如当前的user），可能没有列表。

此外，所有的列表在通过labels返回对象时都应该支持使用label过滤（参见[labels文档](https://kubernetes.io/docs/user-guide/labels/)），大多数列表应该支持使用支持fields过滤（参见[fields文档](https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/)）。

示例：`PodList`，`ServiceList`，`NodeList`。

3. **Simple**是给特定对象的特定动作使用的，以及非持久化对象实体。

鉴于它们的范围有限，它们具有与列表相同的一组有限的通用元数据。

例如，当有错误出现时，会返回“Status”类型，它不存储在系统中。

许多 simple 资源是子资源，坐落在（rooted）某个特定资源api路径下。当资源想要暴露额外的动作，或与某资源有紧密的耦合，应该使用新的子资源来这样做，常见的子资源包括：

* `/binding`：用于将用户请求的资源（例如 Pod、PersistentVolumeClaim）绑定到集群基础设施资源（例如 Node、PersistentVolume）。
* `/status`：仅用于写资源的`status`部分，来更新资源的状态。例如，`/pods`接口仅允许更新`metadata`和`spec`部分，因为这两部反映应用户的意图。一个自动化的程序应能向`/pods/<name>/status`接口向server发送一个更新过的Pod对象来修改状态，以便能够让用户进行观测。该额外接口允许将不同的规则应用于更新，并适当限制访问。
* `/scale`：用于以独立于特定资源模式的方式读取和写入资源的计数。

此外，还有两个子资源，`proxy`和`portforward`，提供了访问额外的[访问集群](https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/)的方式。

标注的REST动词（定义如下）必须返回必须返回单个 JSON 对象。一些API接口可以会偏离严格的REST模式并且返回不是单一JSON对象的资源，如JSON对象流或非结构化的文本日志数据。

一组通用的“元数据”API对象在所有API组中使用，因此被视为meta.k8s.io的API组的一部分。这些类型可能会独立于使用它们的API组而发展，并且API服务器可能允许以它们的通用形式对它们进行寻址。示例是ListOptions、DeleteOptions、List、Status、WatchEvent和Scale。由于历史原因，这些类型是每个现有API组的一部分。配额、垃圾回收、自动缩放器等通用工具和kubectl等通用客户端利用这些类型来定义跨不同资源类型的一致行为，例如编程语言中的 iterface。

### Resources

API返回的所有JSON对象必须具有以下字段：

* kind：一个字符串，标识该对象应具有的模式
* apiVersion：一个字符串，用于标识对象应具有的架构版本

这些字段是正确解码对象所必需的。默认情况下，它们可能由服务器从指定的URL路径填充，但客户端可能需要知道这些值才能构造URL路径。

### Objects

**Metadata**

每个对象的“metadata”下必须包含下列元数据字段：

* `namespace`：namespace是dns兼容的标签，表示对象所在的命名空间。
* `name`：表示对象在当前命名空间中的名称。名称可以用来对单个对象进行检索。
* `uid`：一个唯一的时空值（通常是RFC 4122生成的标识符，[参考](https://kubernetes.io/docs/user-guide/identifiers/)），用于区分以删除和重新创建的同名对象。

每个对象的“metadata”下应该包含下列元数据字段：

* `resourceVersion` 标识对象的内部版本，外部客户端可以根据该字段决定对象是否发生变化。该字段对客户端没有什么特别的意义，但是客户端需要原封不动的将该值传会给服务端（译注：etcd中的全局版本号）。资源版本在不同的命名空间，对于不同类型的资源和不同的服务端没有什么实际的含义（参见下面的并发控制）。
* `generation` 一个代表特定特定期望状态的序号。由系统设置，单调递增，每个资源都有。可以进行比较（译注：spec变化）。
* `creationTimestamp`：一个以RFC 3339标准表示的时间字符串，表示资源对象的创建事件。
* `deletionTimestamp`：一个以RFC 3339标准表示的时间字符串，当超过这个时间后资源会被删除。当用户请求通过优雅的方式删除资源对象时，服务端会给该字段进行设值，客户端是不能够直接设置的。当超过设置的时间后，资源对象会被删除（就不能够通过列表查询到，也不能通过名称获取到），除非该对象有finalizer。在有finalizer的情况下，对象的删除会至少推迟到所有的finalizer移除掉。该字段一旦设置了值，就不能（may not）取消设置，或设置为更后面的时间，尽管它可能会被缩短或在此之前可能就会删除资源。
* `labels`：一组由key-value对组成的字典，用来组织资源对象和分类使用。
* `annotations`：一组由key-value对组成的字典，外部工具可以使用该字段存储和检索任意关于该对象的元数据信息（参见[annotations文档](https://kubernetes.io/docs/user-guide/annotations/)）。

labels的目的是用来给终端用户组织资源使用。annotations可以给第三方自动化程序和工具提供额外的元数据使用能力。

**Spec和Status**

按照惯例，kubernetes api对资源对象的目标状态的规范（spec）和资源对象在当前的状态（status）做区分。

_规范_（spec）是对一个对象目标状态的完整描述，包括用户提供的配置，系统填充的默认值，以及在资源对象创建后由生态内的其他组件（如scheduler）进行初始化或修改的值，然后会持久化到稳定的存储介质中。

_状态_（status）总结描述对象的当前状态，并且通常通过自动化过程与对象一起持久化，但可能会即时（on the fly）生成。作为一般准则，状态字段应该是对实际状态的最新观察，但它们可能包含诸如分配结果或响应对象规范执行的类似操作之类的信息。 请参阅下面的更多细节。

具有规范和状态的类型可以（并且通常应该）具有不同的授权范围。允许用户被授予对规范的完全写入访问权限和对状态的只读访问权限，而相关控制器被授予对规范的只读访问权限但对状态的完全写入访问权限。

当对象的新版本被创建（POST）或更新（PUT）时，规范会更新并立即可用。随着时间的推移，系统将努力使状态符合规范。无论先前版本如何，系统都将朝着最新的规范发展。例如，如果一次更新将值从2更改为5，然后在另一个更新中又回到3，则系统不需要在将状态更改为3之前先到达5。换句话说，系统的行为是基于水平的，而不是基于边缘的。这可以在缺少中间状态更改的情况下实现稳健的行为。

Kubernetes API还作为系统声明性配置模式的基础。为了促进声明性配置的基于级别的操作和表达，规范中的字段应该具有声明性而不是命令性的名称和语义——它们代表所需的状态，而不是旨在产生所需状态的操作。

对象上的创建（POST）和更新（PUT）必须忽略状态（status）值，以避免在读-修改-写场景中意外覆盖状态。必须提供`/status`子资源以使系统组件能够更新它们管理的资源的状态。

此外，更新（PUT）期望是指定整个对象。因此，如果省略了某个字段，则假定客户端想要清楚这个字段的值。PUT不支持部分更新。要想修改资源对象的部分内容，可以先获取（GET）资源，修改资源的`spec`，`lalels`，`annotations`，然后再PUT给服务端。参加下面的并发控制了解读-修改-写模式的一致性。某些对象可能会公开额外资源，以允许更改状态或对对象执行自定义操作。

所有代表物理资源的对象，其状态可能与用户期望的不同，都应该有一个规范（spec）和一个状态（status）。 状态不会与用户期望的不同的对象，可以只有规范（spec），并且可以将“spec”修改为更合适的名称（译注：比如configmap）。

同时包含_规范_和_状态_的对象不应包含标准元数据字段以外的其他顶级字段。

一些不会在在系统中持久化的对象 – 例如`SubjectAccessReview`和其他 webhook风格调用 – 可能会选择添加_规范_和_状态_来封装“调用和响应”模式。规范是请求（通常是信息请求），状态是响应。对于这些类似RPC的对象，唯一的操作可能是POST，但是在提交和响应之间具有一致的模式可以降低这些客户端的复杂性。

\
