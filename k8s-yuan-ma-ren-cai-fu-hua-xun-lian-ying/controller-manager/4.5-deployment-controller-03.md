# 4.5 deployment controller 03

## **dc.sync**

下面来分析一下dc.sync方法，以下两种情况下，都会调用dc.sync，然后直接return：\
（1）判断deployment的`.Spec.Paused`属性值是否为true，是则调用`dc.sync`做处理，调用完成后直接return；\
（2）先调用`dc.isScalingEvent`，检查deployment对象是否处于 `scaling` 状态，是则调用`dc.sync`做处理，调用完成后直接return。

**关于Paused字段**

deployment的`.Spec.Paused`为true时代表该deployment处于暂停状态，false则代表处于正常状态。当deployment处于暂停状态时，deployment对象的PodTemplateSpec的任何修改都不会触发deployment的更新，当`.Spec.Paused`再次赋值为false时才会触发deployment更新。



dc.sync主要逻辑：\
（1）调用`dc.getAllReplicaSetsAndSyncRevision`获取最新的replicaset对象以及旧的replicaset对象列表；\
（2）调用`dc.scale`，判断是否需要进行扩缩容操作，需要则进行扩缩容操作；\
（3）当deployment的`.Spec.Paused`为true且不需要做回滚操作时，调用`dc.cleanupDeployment`，根据deployment配置的保留历史版本数（`.Spec.RevisionHistoryLimit`）以及replicaset的创建时间，把最老的旧的replicaset给删除清理掉；\
（4）调用`dc.syncDeploymentStatus`，计算并更新deployment对象的status字段。

### **dc.scale**

dc.scale主要作用是处理deployment的扩缩容操作，其主要逻辑如下：\
（1）调用`deploymentutil.FindActiveOrLatest`，判断是否只有最新的replicaset对象的副本数不为0，是则找到最新的replicaset对象，并判断其副本数是否与deployment期望副本数一致，是则直接return，否则调用`dc.scaleReplicaSetAndRecordEvent`更新其副本数为deployment的期望副本数；\
（2）当最新的replicaset对象的副本数与deployment期望副本数一致，且旧的replicaset对象中有副本数不为0的，则从旧的replicset对象列表中找出副本数不为0的replicaset，调用`dc.scaleReplicaSetAndRecordEvent`将其副本数缩容为0，然后return；\
（3）当最新的replicaset对象的副本数与deployment期望副本数不一致，旧的replicaset对象中有副本数不为0的，且deployment的更新策略为滚动更新，说明deployment可能正在滚动更新，则按一定的比例对新旧replicaset进行扩缩容操作，保证滚动更新的稳定性，具体逻辑可以自己分析下，这里不展开分析。
