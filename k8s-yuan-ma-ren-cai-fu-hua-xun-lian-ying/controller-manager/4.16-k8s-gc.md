# 4.16 k8s GC

## 背景 <a href="#gai-shu" id="gai-shu"></a>

设想这么一个场景：我们在 K8s 上创建了一个对象，它根据需要生成副本集和 Pod。在检查时，我们遗漏了容器某个属性的设置，因此又重新编辑了 Deployment。新的 Deployment 就产生了新的副本集对象和新的 Pod。这里就出现了一个问题，旧的副本集和 Pop 去哪了？另外，如果直接删除 Deployment，那副本集和 Pod 又会如何？事实就是，在删除 Deployment 后，副本集和 Pod 也会一起被删除，要不然集群早就乱套了。

在这个场景之下，我们可以深入思考几个问题：**在 K8s 中该如何实现级联删除？有几种级联删除策略？在 K8s 中有没有可能存在孤儿对象（orphan object）？**这些问题其实就是典型的垃圾回收（garbage collection，GC）问题。

一般来说，**垃圾回收（GC）就是从系统中删除未使用的对象，并释放分配给它们的计算资源。**GC 存在于所有的高级编程语言中，较低级的编程语言通过系统库实现 GC。

## 概述 <a href="#gai-shu" id="gai-shu"></a>

Kubernetes 和内置垃圾回收编程语言 (例如 Go, Java) 一样，内部也有垃圾回收机制，用于清理集群中的下列资源:

* 终止的 Pod
* 已完成的 Job
* 附属的主对象已经不存在的对象
* 未使用的容器和容器镜像
* StorageClass 回收策略为 Delete 的 PV 卷
* 过期的证书签名
* …

和编程语言中的 GC 运行机制一样，Kubernetes 中的垃圾回收周期自动执行，集群内每个运行 kubelet 的节点上都会有一个垃圾回收器在运行， 可以简单将其理解为一个独立运行的进程甚至一个 goroutine, 事实上，Kubernetes 的垃圾回收是以 **控制器资源** 的形式存在和运行的。

## Owner, Dependent <a href="#owner-dependent" id="owner-dependent"></a>

在面向对象的语言中，一些对象会引用其他对象或者直接由其他对象组成，k8s 也有类似形式，例如副本集管理一组 Pod，而 Deployment 又管理着副本集。

但与面向对象语言不同的是，在 K8s 对象的定义中，没有明确所有者之间的关系，那么系统要如何确定它们的关系呢？其实，在 K8s 中，每个从属对象都具有 唯一数据字段名称 `metadata.ownerReferences` 用于确定关系。

Kubernetes 中被依赖的资源对象称之为 Owner (属主资源), 依赖其他资源的对象称之为 Dependent (依赖资源), 例如我们创建了一个副本数量为 3 的 Deployment。

```yaml
# 官方示例 controllers/nginx-deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3 # 副本数量，可以根据实际情况修改
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

那么会产生如下的依赖关系:

* Pod 作为 ReplicaSet 的 Dependent, 它的 Owner 为 ReplicaSet (Deployment 底层实现需要 ReplicaSet)
* ReplicaSet 作为 Owner 的同时也同样作为 Dependent, 它的 Owner 为 Deployment, Dependent 为 3 个依赖它的 Pod
* Deployment 作为 Owner, 它的 Dependent 为依赖的 ReplicaSet

<figure><img src="../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

#### 回收机制 <a href="#hui-shou-ji-zhi" id="hui-shou-ji-zhi"></a>

默认情况下，垃圾回收采用的是级联删除机制，例如删除 ReplicaSet 资源对象 R1 之后，会删除依赖 R1 资源对象的 Pod 资源对象， 级联删除有两种类型: **前台级联删除** 和 **后台级联删除**。

**前台级联删除:** 当资源对象进入垃圾回收过程，垃圾回收控制器先删除其全部依赖 (Dependent) 对象，然后删除该资源 (Owner) 对象。

**后台级联删除:** API Server 立即删除该资源 (Owner) 对象，然后由垃圾回收控制器在后台清理其全部依赖 (Dependent) 对象，这是 Kubernetes 默认使用的级联删除方案。

#### 孤儿资源对象 <a href="#gu-er-zi-yuan-dui-xiang" id="gu-er-zi-yuan-dui-xiang"></a>

当 Kubernetes 删除某个资源 (Owner) 对象时，其全部依赖 (Dependent) 对象被称作被遗弃的 (Orphaned) 孤儿资源对象，该功能由下文中的 **Finalizer** 来实现。

#### Finalizer <a href="#finalizer" id="finalizer"></a>

Finalizer 用于防止误操作删除了集群依赖的正常运行资源，Finalizer 可以作为资源对象的属性和资源进行绑定，用于执行资源对象在删除之前的逻辑， 所有对象在删除之前，其 Finalizer 属性字段必须为 `nil`, API Server 才会删除该对象，这样就可以防止级联删除了。

例如，现在试图删除一个正在被多个 Pod 使用的 PersistentVolume (持久卷) 资源，那么该 PersistentVolume 资源不会被理解删除， 因为 PersistentVolume 资源注册了 Finalizer 。

除了防止级联删除之外，还可以在资源对象删除之前执行指定的钩子函数，例如在一些场景中只想删除当前资源对象，而不想级联删除其依赖对象， 这时就可以在该资源对象上注册 OrphanFinalizer, 那么垃圾回收控制器在删除该资源对象之后，会忽略其依赖对象，这样给开发者自定义实现提供了更强的灵活性。

## 源码 <a href="#yuan-ma-shuo-ming" id="yuan-ma-shuo-ming"></a>

本文着重从源代码的角度分析一下 GarbageCollector 的实现原理，GarbageCollector 功能对应的源代码位于 Kubernetes 项目的 `pkg/controller/garbagecollector/` 目录，本文以 Kubernetes `v1.30.0` 版本源代码进行分析。

<figure><img src="../../.gitbook/assets/image (27).png" alt=""><figcaption></figcaption></figure>

### GarbageCollector <a href="#garbagecollector" id="garbagecollector"></a>

<pre class="language-go"><code class="lang-go"><strong>// GarbageCollector 对象表示垃圾回收控制器，是实现垃圾回收功能的核心对象。
</strong><strong>type GarbageCollector struct {
</strong>	...
	
	// attemptToDelete 队列
	// 存储垃圾回收尝试删除的资源对象
	attemptToDelete workqueue.RateLimitingInterface
	// attemptToOrphan 队列
	// 存储垃圾回收尝试删除的资源对象所依赖的对象
	attemptToOrphan        workqueue.RateLimitingInterface
	// 资源对象 DAG 构造器 
	dependencyGraphBuilder *GraphBuilder
}
</code></pre>

通过监听资源变化并将结果构造为 DAG (有向无环图) 结构，DAG 对象存储了集群中不同资源对象之间的从属关系，当 DAG 发生变化时， 对应的资源对象可能会被垃圾回收加入到 `attemptToDelete` 队列，并将对象依赖的对象加入到 `attemptToOrphan` 队列。

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

garbage collector中最关键的代码就是`garbagecollector.go`与`graph_builder.go`两部分。

garbage collector的主要组成为1个图（对象关联依赖关系图）、2个处理器（`GraphBuilder`与`GarbageCollector`）、3个事件队列（`graphChanges`、`attemptToDelete`与`attemptToOrphan`）：

#### **1个图**

（1）`uidToNode`：对象关联依赖关系图，由`GraphBuilder`维护，维护着所有对象间的关联依赖关系。在该图里，每一个k8s对象会对应着关系图里的一个`node`，而每个`node`都会维护一个`owner`列表以及`dependent`列表。

示例：现有一个deployment A，replicaset B（owner为deployment A），pod C（owner为replicaset B），则对象关联依赖关系如下：

```
3个node，分别是A、B、C

A对应一个node，无owner，dependent列表里有B；  
B对应一个node，owner列表里有A，dependent列表里有C；  
C对应一个node，owner列表里有B，无dependent。  
```

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

#### **2个处理器**

（1）`GraphBuilder`：负责维护所有对象的关联依赖关系图，并产生事件触发`GarbageCollector`执行对象回收删除操作。`GraphBuilder`从`graphChanges`事件队列中获取事件进行消费，根据资源对象中`ownerReference`的值，来构建、更新、删除对象间的关联依赖关系图，也即`owner`与`dependent`之间的关系图，然后再作为生产者生产事件，放入`attemptToDelete`或`attemptToOrphan`队列中，触发`GarbageCollector`执行，看是否需要进行关联对象的回收删除操作，而`GarbageCollector`进行对象的回收删除操作时会依赖于`uidToNode`这个关系图。

（2）`GarbageCollector`：负责回收删除对象。`GarbageCollector`作为消费者，从`attemptToDelete`与`attemptToOrphan`队列中取出事件进行处理，若一个对象被删除，且其删除策略为级联删除，则进行关联对象的回收删除。关于删除关联对象，细一点说就是，使用级联删除策略去删除一个`owner`时，会连带这个`owner`对象的`dependent`对象也一起删除掉。



#### **3个事件队列**

（1）`graphChanges`：list/watch apiserver，获取事件，由`informer`生产，由`GraphBuilder`消费；

（2）`attemptToDelete`：级联删除事件队列，由`GraphBuilder`生产，由`GarbageCollector`消费；

（3）`attemptToOrphan`：孤儿删除事件队列，由`GraphBuilder`生产，由`GarbageCollector`消费。



### 初始化 <a href="#chu-shi-hua" id="chu-shi-hua"></a>

`NewGarbageCollector` 方法初始化`GraphBuilder`结构体，并赋值给`GarbageCollector`结构体的`dependencyGraphBuilder`属性

```go
func NewGarbageCollector(...) (*GarbageCollector, error) {
// NewGarbageCollector creates a new GarbageCollector.
func NewGarbageCollector(
	ctx context.Context,
	kubeClient clientset.Interface,
	metadataClient metadata.Interface,
	mapper meta.ResettableRESTMapper,
	ignoredResources map[schema.GroupResource]struct{},
	sharedInformers informerfactory.InformerFactory,
	informersStarted <-chan struct{},
) (*GarbageCollector, error) {
	graphBuilder := NewDependencyGraphBuilder(ctx, metadataClient, mapper, ignoredResources, sharedInformers, informersStarted)
	return NewComposedGarbageCollector(ctx, kubeClient, metadataClient, mapper, graphBuilder)
}
```

### 启动入口 <a href="#qi-dong-ru-kou" id="qi-dong-ru-kou"></a>

垃圾回收的启动入口位于 Kubernetes 项目的 `/cmd/kube-controller-manager/app/core.go` 文件中。

```go
func startGarbageCollectorController(ctx context.Context, ...) (controller.Interface, bool, error) {
	// 初始化 NewGarbageCollector 对象需要的各项参数
	
	...

	// 设置垃圾回收需要忽视的资源类型
	ignoredResources := make(map[schema.GroupResource]struct{})
	for _, r := range controllerContext.ComponentConfig.GarbageCollectorController.GCIgnoredResources {
		ignoredResources[schema.GroupResource{Group: r.Group, Resource: r.Resource}] = struct{}{}
	}
	
	// 创建一个 NewGarbageCollector 对象
	garbageCollector, err := garbagecollector.NewGarbageCollector(
        ...
	)
	
	// 获取垃圾回收并发的 goroutine 数量 (默认为 20 个)
	workers := int(controllerContext.ComponentConfig.GarbageCollectorController.ConcurrentGCSyncs)
	// 启动垃圾回收
	go garbageCollector.Run(ctx, workers)

	// 监听集群内的资源对象变化并同步需要被删除的资源对象
	go garbageCollector.Sync(ctx, discoveryClient, 30*time.Second)

	return garbageCollector, true, nil
}
```

从上面的源代码可以看到，启动垃圾回收器时，调用的核心方法为 `GarbageCollector.Run` 和 `GarbageCollector.Sync`。

### Run

&#x20;`GarbageCollector.Run` 方法作为垃圾回收器的入口方法，主要做两件事情:

1. 单独启动一个 goroutine 执行资源对象的 DAG 构造和同步
2. 根据配置启动相应数量的 goroutine 来处理存储将被回收的资源对象的 `attemptToDelete` 队列和`attemptToOrphan` 队列

```go
func (gc *GarbageCollector) Run(ctx context.Context, workers int) {
	...
	
        // 启动一个 goroutine 执行 DAG 的构建
        // gc.dependencyGraphBuilder.Run负责启动启动GraphBuilder，主要逻辑如下：
	//（1）调用gb.startMonitors，启动 infomers；
	//（2）每隔1s循环调用gb.runProcessGraphChanges，做GraphBuilder的核心逻辑处理
	go gc.dependencyGraphBuilder.Run(ctx)

	// 等待所有资源对象的 DAG 构建完成
	if !cache.WaitForNamedCacheSync("garbage collector", ctx.Done(), func() bool {
		return gc.dependencyGraphBuilder.IsSynced(logger)
	}) {
		return
	}
	
	// 所有准备工作就绪之后，就可以执行垃圾回收了
	
	// 根据配置启动多个 goroutine 来执行垃圾回收
	for i := 0; i < workers; i++ {
		// 负责回收队列中要被删除的对象，内部是一个无限循环，通过调用 processAttemptToDeleteWorker 方法来决定退出的具体条件
		go wait.UntilWithContext(ctx, gc.runAttemptToDeleteWorker, 1*time.Second)
		go wait.Until(func() { gc.runAttemptToOrphanWorker(logger) }, 1*time.Second, ctx.Done())
	}

	<-ctx.Done()
}
```

### Sync

周期性的查询集群中所有的`deletableResources`，调用`gc.resyncMonitors`来更新`GraphBuilder`的`monitors`，为新出现的资源对象初始化`infomer`和注册`eventHandler`，然后启动`infomer`，对已经移除的资源对象的`monitors`进行销毁。

```go
func (gc *GarbageCollector) Sync(ctx context.Context, ...) {
	    // 获取可以被回收的资源对象
		newResources, err := GetDeletableResources(logger, discoveryClient)
		
		...

		// 检测可回收对象是否发生变化
		// 如果没有任何对象发生变化，意味着本轮垃圾回收无需执行
		if reflect.DeepEqual(oldResources, newResources) {
			return
		}

        // 代码执行到这里，说明需要进行一轮垃圾回收操作
        // 因为垃圾回收过程中涉及到重建资源 DAG
        // 所以需要加锁，暂停异步执行的 goroutine
        gc.workerLock.Lock()
        defer gc.workerLock.Unlock()

		attempt := 0
		wait.PollImmediateUntilWithContext(ctx, 100*time.Millisecond, func(ctx context.Context) (bool, error) {
			attempt++

			// 每一轮, 重新获取可以被回收的资源对象
			if attempt > 1 {
				newResources, err = GetDeletableResources(logger, discoveryClient)
				
				...
			}
			
			// 重置 REST mapper
			gc.restMapper.Reset()
			
			// 同步 resource monitors
			if err := gc.resyncMonitors(logger, newResources); err != nil {
				return false, nil
			}

			// 等待所有资源对象的 DAG 构建完成
			if !cache.WaitForNamedCacheSync("garbage collector", waitForStopOrTimeout(ctx.Done(), period), func() bool {
				return gc.dependencyGraphBuilder.IsSynced(logger)
			}) {
                ...
				return false, nil
			}
			
			return true, nil
		})

		// 更换新旧资源对象
		oldResources = newResources
	}, period)
}
```

#### gc.resyncMonitors

调用`gc.dependencyGraphBuilder.syncMonitors`：初始化`infomer`和注册`eventHandler`；\
调用`gc.dependencyGraphBuilder.startMonitors`：启动`infomer`。

```go
// resyncMonitors starts or stops resource monitors as needed to ensure that all
// (and only) those resources present in the map are monitored.
func (gc *GarbageCollector) resyncMonitors(logger klog.Logger, deletableResources map[schema.GroupVersionResource]struct{}) error {
	if err := gc.dependencyGraphBuilder.syncMonitors(logger, deletableResources); err != nil {
		return err
	}
	gc.dependencyGraphBuilder.startMonitors(logger)
	return nil
}
```

### NewDebugHandler

garbagecollector.NewDebugHandler暴露http服务，注册 debug 接口，用于debug，用来提供由`GraphBuilder`构建的集群内所有对象的关联关系。

获取全部的对象关联关系图：

```css
curl http://{master_ip}:{kcm_port}/debug/controllers/garbagecollector/graph -o {output_file}
```

获取特定uid的对象关联关系图：

```bash
curl http://{master_ip}:{kcm_port}/debug/controllers/garbagecollector/graph?uid={project_uid} -o {output_file}
```

示例：

```bash
curl http://192.168.1.10:10252/debug/controllers/garbagecollector/graph?uid=8727f640-112e-21eb-11dd-626400510df6 -o /home/test
```

```go
func (h *debugHTTPHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	if req.URL.Path != "/graph" {
		http.Error(w, "", http.StatusNotFound)
		return
	}

	var nodes []*dotVertex
	var edges []dotEdge
	if uidStrings := req.URL.Query()["uid"]; len(uidStrings) > 0 {
		uids := []types.UID{}
		for _, uidString := range uidStrings {
			uids = append(uids, types.UID(uidString))
		}
		nodes, edges = h.controller.dependencyGraphBuilder.uidToNode.ToDOTNodesAndEdgesForObj(uids...)

	} else {
		nodes, edges = h.controller.dependencyGraphBuilder.uidToNode.ToDOTNodesAndEdges()
	}

	b := bytes.NewBuffer(nil)
	if err := marshalDOT(b, nodes, edges); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "text/vnd.graphviz")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.Write(b.Bytes())
	w.WriteHeader(http.StatusOK)
}

func (gc *GarbageCollector) DebuggingHandler() http.Handler {
	return NewDebugHandler(gc)
}

```
